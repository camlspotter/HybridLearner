/*
 * runAT.cpp
 *
 *  Created on: 25-Jan-2022
 *      Author: amit
 */


#include "runAT.h"


void runAT(std::unique_ptr<MATLABEngine> &ep, user_inputs::ptr user, std::list<struct timeseries_input> initial_CE_values, intermediateResult::ptr intermediate) {
	//cout << "List of initial values are " << endl;
	/*for (unsigned int i=0; i< initial_CE_values.size(); i++) {
		cout << initial_CE_values[i] << " ,  ";
	}
	cout << endl;*/



// ***** Example to pass vector data to Matlab using MatlabEngine ******
	/*std::vector<double> cppData{ 4, 8, 12, 16, 20, 24 };
	size_t x=1, y=6;	//Must use size_t other data types did not worked
	// Create a x-by-y matlab data array
	matlab::data::ArrayFactory factory;
	auto inputArray = factory.createArray({ x, y }, cppData.cbegin(), cppData.cend());
	ep->setVariable(u"cp_data", inputArray); 	//This example puts the variable named data in the MATLAB base workspace.*/
// ***** Example to pass vector data to Matlab using MatlabEngine ******


	std::string cmd4 = "time_horizon = ";
	cmd4.append(to_string(user->getTimeHorizon()));
	cmd4.append(";");
	ep->eval(convertUTF8StringToUTF16String(cmd4));

	cmd4 = "time_step = ";
	cmd4.append(to_string(user->getSampleTime()));
	cmd4.append(";");
	ep->eval(convertUTF8StringToUTF16String(cmd4));

	std::list<struct timeseries_input>::iterator it_values = initial_CE_values.begin();

//	list<vector<double>> var_control_points = initial_CE_values.var_values;
//	list<vector<double>> time_for_cp = initial_CE_values.time_values;
//
//
//	// *** Because we know that the AT model has first two variables as input variables ***
	//Todo: May be we can check the variable name before accessing var_values and time_values
//	list<vector<double>>::iterator it = var_control_points.begin();
//	list<vector<double>>::iterator it_time = time_for_cp.begin();

	//cout << "Time-Horizon and time-step Done " << endl;

	std::vector<double> cppData = (*it_values).var_values;
	size_t x=1, y=cppData.size();
	matlab::data::ArrayFactory factory;
	auto inputArray = factory.createArray({ x, y }, cppData.cbegin(), cppData.cend());
	ep->setVariable(u"throttle_input", inputArray);

	std::vector<double> cppTime = (*it_values).time_values;
	assert(y == cppTime.size());
	matlab::data::ArrayFactory factory1;
	auto inputArray1 = factory1.createArray({ x, y }, cppTime.cbegin(), cppTime.cend());
	ep->setVariable(u"timeVector_throttle", inputArray1);


	it_values++;
	cppData = (*it_values).var_values;
	size_t y2=cppData.size();
	matlab::data::ArrayFactory factory2;
	auto inputArray2 = factory2.createArray({ x, y2 }, cppData.cbegin(), cppData.cend());
	ep->setVariable(u"BrakeTorque_input", inputArray2);

	cppTime = (*it_values).time_values;
	//y2=cppTime.size();
	assert(y2 == cppTime.size());
	matlab::data::ArrayFactory factory3;
	auto inputArray3 = factory3.createArray({ x, y2 }, cppTime.cbegin(), cppTime.cend());
	ep->setVariable(u"timeVector_brake", inputArray3);
// **** End of Input Signal Generation ****

	//cout << "Pedal-angle and engine-speed Done " << endl;
/*
	cmd4 = "x0_0 = ";
	cmd4.append(to_string(initial_CE_values[0]));
	cmd4.append(";");
	ep->eval(convertUTF8StringToUTF16String(cmd4));

	cmd4 = "x1_0 = ";
	cmd4.append(to_string(initial_CE_values[1]));
	cmd4.append(";");
	ep->eval(convertUTF8StringToUTF16String(cmd4));
*/

	//exit(0);



	unsigned int execution_count = user->getNumberMatlabSimulationExecuted();

	//Removing the files generated by Matlab in the previous run
	if (execution_count == 0) {	//running for the first time
        std::string cmd="rm result.txt";
		int x = system(cmd.c_str());
		if (x == -1) {
			std::cout <<"Error executing cmd: " << cmd <<std::endl;
		}
	}

	cout << "Before calling run_AT" << endl;
	//ep->eval(convertUTF8StringToUTF16String("run_oscillator"));
	ep->eval(u"run_AT");


	//This code can be used for other Models also.
	/*engEvalString(ep, "plot(x1,x2);");
	engEvalString(ep, "title('x1 vs. x2 of the Plot');");
	engEvalString(ep, "xlabel('x1');");
	engEvalString(ep, "ylabel('x2');");*/

	std::cout << "Done Calling Matlab's AT Simulink (simulation)\n" << std::endl;

}

