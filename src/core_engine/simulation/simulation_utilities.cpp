/*
 * simulation_utilities.cpp
 *
 *  Created on: 28-Jul-2022
 *      Author: amit
 */

#include "../../utilities/matlab.h"

#include "../../commandLineParser/user_inputs.h"
#include "../../utilities/intermediateResult.h"
#include "../../hybridautomata/hybridAutomata.h"
#include "../../commandLineParser/parameters.h"
#include "../../commandLineParser/user_inputs_helper.h"
#include "../../simulinkModelling/simulinkModelConstructor.h"
#include "../../io_functions/summary.h"
#include "../../io_functions/data_structs.h"
#include <boost/timer/timer.hpp>
#include "../learn_ha/model_setup.h"
#include "../../utilities/myRandomNumberGenerator.h"
#include "../../utilities/polytope/polytope.h"
#include "../../simulation/simulation.h"
#include "../../utilities/filesystem.h"
#include "../../utilities/system.h"
/*
 * This function is used in engine:
 * 		simu
 * 		equi-test
 * 		learn-ha-loop
 *
 */
void simu_model_file(std::unique_ptr<MATLABEngine> &ep,
                     user_inputs::ptr user,
                     std::list<struct timeseries_input> initial_CE_values,
                     std::vector<double> initial_output_values,
                     std::string script_filename,
                     std::string output_filename,
                     intermediateResult::ptr intermediate,
                     hybridAutomata::ptr ha)
{
	//Populate data in the Matlab's Workspace
	for (std::list<struct timeseries_input>::iterator it_values = initial_CE_values.begin(); it_values != initial_CE_values.end(); it_values++) {
		string varName = it_values->var_detail.var_name;
		if (user->isInputVariable(varName)) {
			std::vector<double> cppData = it_values->var_values;
			std::vector<double> cppTime = it_values->time_values;
			assert(cppData.size() == cppTime.size());
			size_t x=1, y=cppData.size(); // array dimensions

            {
                std::string inputDataValues = formatString("%s_input", varName.c_str()); //Eg.  x0_input
                matlab::data::ArrayFactory factory;
                auto inputArray = factory.createArray({ x, y }, cppData.cbegin(), cppData.cend());
                MATLAB_SETVAR(ep, inputDataValues, inputArray);
            }

			{
                std::string inputTimeValues = formatString("%s_time", varName.c_str()); // Eg.  x0_input
                matlab::data::ArrayFactory factory;
                auto inputArray = factory.createArray({ x, y }, cppTime.cbegin(), cppTime.cend());
                MATLAB_SETVAR(ep, inputTimeValues, inputArray);
            }

		}
	}

	//use output variables to match only output variables and get the value. Assumed order is maintained even in the initial polytope creation
	assert(initial_output_values.size() == ha->map_size());	//double check

	for (unsigned int index=0; index < ha->map_size(); index++) {
        std::string varName = ha->get_varname(index);
		if (!(user->isInputVariable(varName))) {
            MATLAB_EVAL(ep, formatString("a%d = %.12g;", index, initial_output_values[index]));
		}
	}

	unsigned int execution_count = user->getNumberMatlabSimulationExecuted();

	//Removing the files generated by Matlab in the previous run
	if (execution_count == 0) {	//running for the first time
        fs::remove(output_filename);
	}

	// Now running the script file that will perform simulation.
	MATLAB_RUN(ep, script_filename);

    // cout << "simu_model_file() done" << endl;
}





// XXX Large dupe of simu_model_file
void simulate_model(std::unique_ptr<MATLABEngine> &ep,
                    user_inputs::ptr &user,
                    std::list<struct timeseries_input> initial_CE_values,
                    std::vector<double> &initial_output_values,
                    std::string script_filename,
                    std::string output_filename,
                    intermediateResult::ptr &intermediate,
                    hybridAutomata::ptr &ha,
                    model_setup::ptr la_setup)
{
	std::list<struct variable_mapping> userVariableMapping = la_setup->getUserVariableMapping();

	for (std::list<struct timeseries_input>::iterator it_values = initial_CE_values.begin(); it_values != initial_CE_values.end(); it_values++) {
		string varName = it_values->var_detail.var_name;
		//Find equivalent learned variable name for varName

		if (user->isInputVariable(varName)) {
			std::string inputDataValues="", inputTimeValue="";
			inputDataValues.append(varName);
			inputDataValues.append("_input");	//Eg.  x0_input

			std::vector<double> cppData = (*it_values).var_values;

			size_t x=1, y=cppData.size();
			matlab::data::ArrayFactory factory;
			auto inputArray = factory.createArray({ x, y }, cppData.cbegin(), cppData.cend());
			ep->setVariable(convertUTF8StringToUTF16String(inputDataValues), inputArray);

			inputTimeValue.append(varName);
			inputTimeValue.append("_time");	//Eg.  x0_input

			std::vector<double> cppTime = (*it_values).time_values;
			assert(y == cppTime.size());
			matlab::data::ArrayFactory factory1;
			auto inputArray1 = factory1.createArray({ x, y }, cppTime.cbegin(), cppTime.cend());
			//ep->setVariable(u"timeVector_pedal_angle", inputArray1);
			ep->setVariable(convertUTF8StringToUTF16String(inputTimeValue), inputArray1);

		}
	}

	//use output variables to match only output variables and get the value. Assumed order is maintained even in the initial polytope creation
	assert(initial_output_values.size() == ha->map_size());	//double check
	for (unsigned int index=0; index < ha->map_size(); index++) {
		std::string varName = ha->get_varname(index);
		//std::cout <<"Variable Name=" << varName << std::endl;
        //	std::cout <<"Original varName:" << varName << " index:" << index << std::endl;
		std::string cmd = "a";
		if (!(user->isInputVariable(varName))) {	//since user and ha has some variable mapping, so in any case input variable will not be same as output variable
			cmd.append(to_string(index));
			cmd.append(" = ");
			cmd.append(to_string(initial_output_values[index]));	//Here the index of initial_output_values include both input and output variables.
			cmd.append(";");
			//modelfile << "a" << index << " = " << initial_output_values[index] ;
			MATLAB_EVAL(ep, cmd);
		}
	}

	unsigned int execution_count = user->getNumberMatlabSimulationExecuted();

	//Removing the files generated by Matlab in the previous run
	if (execution_count == 0) {	//running for the first time
        fs::remove(output_filename);
    }

	// Now running the script file that will perform simulation.
	MATLAB_RUN(ep, script_filename);
	std::cout << "Done Calling Matlab's simulation on Original .slx model.\n" << std::endl;
}





// XXX Large dupe of simu_model_file
/*
 * Variable names need to be handled differently for 1) original and 2) learned model
 * Here initial_CE_values and initial_output_values are having variables names of original model
 */
void simulate_learned_model_from_learn_ha_loop(std::unique_ptr<MATLABEngine> &ep,
                                               user_inputs::ptr &user,
                                               std::list<struct timeseries_input> initial_CE_values,
                                               std::vector<double> &initial_output_values,
                                               std::string script_filename,
                                               std::string output_filename,
                                               intermediateResult::ptr &intermediate,
                                               hybridAutomata::ptr &ha,
                                               model_setup::ptr la_setup)
{

    //    cout << "simulate_learned_model-from_learn_ha_loop "
    //         << "script_filename: " << script_filename << " , " 
    //         << "output_filename: " << output_filename << endl;
        
	//std::cout <<"Let us see the control points" << std::endl;
	//std::cout <<"initial_CE_values.size()=" << initial_CE_values.size() << std::endl;
	//Populate data in the Matlab's Workspace

	std::list<struct variable_mapping> userVariableMapping = la_setup->getUserVariableMapping();

	for (std::list<struct timeseries_input>::iterator it_values = initial_CE_values.begin(); it_values != initial_CE_values.end(); it_values++) {
		string varName = it_values->var_detail.var_name;
		//Find equivalent learned variable name for varName
		//std::cout <<"Input Variable Name=" << varName << std::endl;
		string equi_varName = la_setup->getEquivalentLearnedVariableName(userVariableMapping, varName);
		//std::cout <<"equi_varName Variable Name=" << equi_varName << std::endl;
		varName = equi_varName;

		if (user->isInputVariable(varName)) {
			std::string inputDataValues="", inputTimeValue="";
			inputDataValues.append(varName);
			inputDataValues.append("_input");	//Eg.  x0_input

			std::vector<double> cppData = (*it_values).var_values;
			//std::cout <<"cppData.size =" << cppData.size() << std::endl;

			size_t x=1, y=cppData.size();
			matlab::data::ArrayFactory factory;
			auto inputArray = factory.createArray({ x, y }, cppData.cbegin(), cppData.cend());
			//ep->setVariable(u"cp_pedal_angle", inputArray);
			ep->setVariable(convertUTF8StringToUTF16String(inputDataValues), inputArray);

			inputTimeValue.append(varName);
			inputTimeValue.append("_time");	//Eg.  x0_input

			std::vector<double> cppTime = (*it_values).time_values;
			//std::cout <<"Last time of the input variable (cp_pedal_angle) = " << cppTime[cppTime.size()-1] <<endl;
			assert(y == cppTime.size());
			matlab::data::ArrayFactory factory1;
			auto inputArray1 = factory1.createArray({ x, y }, cppTime.cbegin(), cppTime.cend());
			//ep->setVariable(u"timeVector_pedal_angle", inputArray1);
			ep->setVariable(convertUTF8StringToUTF16String(inputTimeValue), inputArray1);

		}
	}


	//use output variables to match only output variables and get the value. Assumed order is maintained even in the initial polytope creation
	assert(initial_output_values.size() == ha->map_size());	//double check
	for (unsigned int index=0; index < ha->map_size(); index++) {
		std::string varName = ha->get_varname(index);
		//std::cout <<"Variable Name=" << varName << std::endl;
		//std::cout <<"Output varName:" << varName << " index:" << index << std::endl;
		std::string cmd = "a";
		if (!(user->isInputVariable(varName))) {	//since user and ha has some variable mapping, so in any case input variable will not be same as output variable
			cmd.append(to_string(index));
			cmd.append(" = ");
			cmd.append(to_string(initial_output_values[index]));	//Here the index of initial_output_values include both input and output variables.
			cmd.append(";");
			//modelfile << "a" << index << " = " << initial_output_values[index] ;
			MATLAB_EVAL(ep, cmd);
		}
	}

	unsigned int execution_count = user->getNumberMatlabSimulationExecuted();

	std::string path_user_Model_str = getcwd();

//	//Removing the files generated by Matlab in the previous run
//	if (execution_count == 0) {	//running for the first time
//
//		{
//            std::string cmd = "addpath (genpath('";
//            cmd.append(path_user_Model_str);
//            cmd.append("'))");
//            MATLAB_EVAL(ep, cmd);
//        }
//	}

	// Now running the script file that will perform simulation.
	MATLAB_RUN(ep, script_filename);
	std::cout << "Done Calling Matlab's simulation on Learned .slx model.\n" << std::endl;

}

// XXX Large dupe of simu_model_file
void simulate_original_model_from_learn_ha_loop(std::unique_ptr<MATLABEngine> &ep,
                                                user_inputs::ptr &user,
                                                std::list<struct timeseries_input> initial_CE_values,
                                                std::vector<double> &initial_output_values,
                                                std::string script_filename,
                                                std::string output_filename,
                                                intermediateResult::ptr &intermediate,
                                                hybridAutomata::ptr &ha,
                                                model_setup::ptr la_setup)
{
	//std::cout <<"Let us see the control points" << std::endl;
	//std::cout <<"initial_CE_values.size()=" << initial_CE_values.size() << std::endl;
	//Populate data in the Matlab's Workspace

	std::list<struct variable_mapping> userVariableMapping = la_setup->getUserVariableMapping();

	for (std::list<struct timeseries_input>::iterator it_values = initial_CE_values.begin(); it_values != initial_CE_values.end(); it_values++) {
		string varName = it_values->var_detail.var_name;
		//Find equivalent learned variable name for varName
	//	std::cout <<"Original Variable Name=" << varName << std::endl;

		if (user->isInputVariable(varName)) {
			std::string inputDataValues="", inputTimeValue="";
			inputDataValues.append(varName);
			inputDataValues.append("_input");	//Eg.  x0_input

			std::vector<double> cppData = (*it_values).var_values;
			//std::cout <<"cppData.size =" << cppData.size() << std::endl;

			size_t x=1, y=cppData.size();
			matlab::data::ArrayFactory factory;
			auto inputArray = factory.createArray({ x, y }, cppData.cbegin(), cppData.cend());
			//ep->setVariable(u"cp_pedal_angle", inputArray);
			ep->setVariable(convertUTF8StringToUTF16String(inputDataValues), inputArray);

			inputTimeValue.append(varName);
			inputTimeValue.append("_time");	//Eg.  x0_input

			std::vector<double> cppTime = (*it_values).time_values;
			//std::cout <<"Last time of the input variable (cp_pedal_angle) = " << cppTime[cppTime.size()-1] <<endl;
			assert(y == cppTime.size());
			matlab::data::ArrayFactory factory1;
			auto inputArray1 = factory1.createArray({ x, y }, cppTime.cbegin(), cppTime.cend());
			//ep->setVariable(u"timeVector_pedal_angle", inputArray1);
			ep->setVariable(convertUTF8StringToUTF16String(inputTimeValue), inputArray1);

		}
	}


	//use output variables to match only output variables and get the value. Assumed order is maintained even in the initial polytope creation
	assert(initial_output_values.size() == ha->map_size());	//double check
	for (unsigned int index=0; index < ha->map_size(); index++) {
		std::string varName = ha->get_varname(index);
		//std::cout <<"Variable Name=" << varName << std::endl;
        //	std::cout <<"Original varName:" << varName << " index:" << index << std::endl;
		std::string cmd = "a";
		if (!(user->isInputVariable(varName))) {	//since user and ha has some variable mapping, so in any case input variable will not be same as output variable
			cmd.append(to_string(index));
			cmd.append(" = ");
			cmd.append(to_string(initial_output_values[index]));	//Here the index of initial_output_values include both input and output variables.
			cmd.append(";");
			//modelfile << "a" << index << " = " << initial_output_values[index] ;
			MATLAB_EVAL(ep, cmd);
		}
	}

	unsigned int execution_count = user->getNumberMatlabSimulationExecuted();

	//Removing the files generated by Matlab in the previous run
	if (execution_count == 0) {	//running for the first time
        fs::remove(output_filename);
    }

	// Now running the script file that will perform simulation.
	MATLAB_RUN(ep, script_filename);
	std::cout << "Done Calling Matlab's simulation on Original .slx model.\n" << std::endl;

}

/*
 * This function is called from engine:
 * 		simulation: Here MATLAB engine has not yet started
 *
 */
void generate_input_information(std::list<struct timeseries_all_var> &initial_simulation_timeSeriesData_ret, // out
                                std::list< std::vector<double> > &initial_output_values_ret, // out
                                parameters::ptr &params,
                                std::unique_ptr<MATLABEngine> &ep, // out
                                summary::ptr &report)
{
    // cout << "generate_input_information()..." << endl;

	user_inputs::ptr userInputs = params->getUserInputs();

	// -------------------    generating input time-serise data   ---------------------
	unsigned int userSeedValue = userInputs->getSeed();
	myRandomNumberGenerator::ptr randomGenObject = myRandomNumberGenerator::ptr(new myRandomNumberGenerator(userSeedValue));  // setting 100 as default seed
	params->setRandomGenObj(randomGenObject);

    // XXX Why taking a copy?
	user_inputs::ptr user_copy = user_inputs::ptr(new user_inputs());
	user_copy = userInputs;

	boost::timer::cpu_timer timer;
	timer.start();

	ep = connectMATLAB();

	timer.stop();
	double wall_clock;
	wall_clock = timer.elapsed().wall / 1000000; //convert nanoseconds to milliseconds
	double running_time = wall_clock / (double) 1000;	//convert milliseconds to seconds
	report->setRuntimeMatlabStart(running_time);

	// Creating object of user_inputs_helper class for calling helper functions
	user_inputs_helper::ptr user_inputs_helper_object = user_inputs_helper::ptr(new user_inputs_helper());

	initial_simulation_timeSeriesData_ret = user_inputs_helper_object->generate_input_signals(ep, params);  //create init_poly in this function

/*
	// Debug call from equi-test -------------
	std::list<struct timeseries_all_var>::iterator test_it = initial_simulation_timeSeriesData.begin();
	cout << "size=" << (*test_it).timeseries_signal.size();
	// -------------
*/

/*
	//Debug ----
	cout <<"Check-out size=" << initial_simulation_timeSeriesData.size()<< endl;
	for (std::list<struct timeseries_all_var>::iterator it=initial_simulation_timeSeriesData.begin(); it != initial_simulation_timeSeriesData.end(); it++) {
		cout <<"\nData Set Details are " << endl;
		std::list<timeseries_input> time_signal = (*it).timeseries_signal;
		cout <<"Check-out size of time-signal per-simulation =" <<time_signal.size()<< endl;
		for (std::list<struct timeseries_input>::iterator it_in = time_signal.begin(); it_in != time_signal.end(); it_in++) {
			cout <<"Variable Name: " << (*it_in).var_detail.var_name << endl;
			cout <<"Number of CPs: " << (*it_in).var_detail.numberOf_cp << endl;
			vector<double> cp_vector = (*it_in).var_detail.cps;
//			cout <<"CPs are: ";
//			for (unsigned int i=0; i<cp_vector.size(); i++)
//				cout <<cp_vector[i] << "\t";
			cout <<"\nTimeVector are: ";
			for (unsigned int i=0; i<(*it_in).time_values.size(); i++)
				cout <<(*it_in).time_values[i] << "\t";
			cout <<"\nDataVector are: ";
			for (unsigned int i=0; i<(*it_in).var_values.size(); i++)
				cout <<(*it_in).var_values[i] << "\t";
		}
	}
	// ----------
*/

	polytope::ptr initial_poly = params->getInitPoly(); //using init_poly created in the above line. todo: verify if params retains the value of init_poly

    //	polytope::ptr initial_poly = toolFrame_for_inputSignal->getInitialPolytope(); //using init_poly created in the above line

    //	std::list<struct timeseries_all_var>::iterator it_single_simu = initial_simulation_timeSeriesData.begin();
    //	std::list<struct timeseries_input> inputVar_init_point = (*it_single_simu).timeseries_signal;	//here we only have a single simulation, so iteration->begin() is fine.
    
	unsigned int number_of_traces;
	if ( user_copy->getEngine()=="simu" || user_copy->getEngine()=="learn-ha" ) {
		number_of_traces = user_copy->getSimuInitSize();
	} else if ( user_copy->getEngine()=="equi-test" || user_copy->getEngine()=="learn-ha-loop" ) {
		unsigned int init_size = user_copy->getSimuInitSize();
		number_of_traces = user_copy->getMaxGenerateTraceSize(); //todo: Remove: used only for taking reproducible reading
	}

	myRandomNumberGenerator::ptr randomGenObject2 = myRandomNumberGenerator::ptr(new myRandomNumberGenerator(100));  // setting 100 as default seed

	initial_output_values_ret = getInternalPoints(initial_poly, number_of_traces, randomGenObject2);

    // cout << "generate_input_information() done" << endl;
}

//runs multiple simulation and creates a trace file.
/*
 * This function is called from engine:
 * 		simulation
 *

 */
void generate_simulation_traces(std::list<struct timeseries_all_var> &initial_simulation_timeSeriesData, std::list<std::vector<double> > &initial_output_values,
		parameters::ptr params, std::unique_ptr<MATLABEngine> &ep) {

	intermediateResult::ptr intermediate = params->getIntermediate();
	user_inputs::ptr userInputs = params->getUserInputs();
	hybridAutomata::ptr H = params->getH();

	//Debug ----
	/*std::cout << "user: sys-dimm="<<userInputs->getSysDimension() <<std::endl;
	std::cout << "user: time-horizon="<<userInputs->getTimeHorizon() <<std::endl;
	std::cout << "user: simu init size="<<userInputs->getSimuInitSize() <<std::endl;
	std::cout << "user: SimulinkModelFilename="<<userInputs->getSimulinkModelFilename() <<std::endl;*/

	// -----

	//Step-2: Obtain .slx model from

	simulinkModelConstructor::ptr model = simulinkModelConstructor::ptr(new simulinkModelConstructor(H, userInputs, intermediate));
	unsigned int iterations_count = 0; // just a label for the first model creation
	model->setIteration(iterations_count);	//this may not be required now


	//create_run_script()	//run_script file containing all the variables populated and command to execute the sim of .slx model
	//We assume file generated is "run_script_simu_user_model.m"
	// Now creating script file for later running the simulation and obtaining output-file having fixed time-step
	//Creating a script file for Running the simulink model just created.
	std::string script_filename = "run_script_simu_user_model.m", output_filename="result_simu_data.txt";
	std::string simulink_model_filename = userInputs->getSimulinkModelFilename();

    std::string fullpath = dirname(simulink_model_filename);
    std::string filename_withOut_path = basename(simulink_model_filename);
	if (boost::algorithm::iequals(fullpath, getcwd().string())==false) {
		//fullpath (including user-supplied path) and $PWD are not equal
		//user supplied some relative path along with simulink-model filename. So copy model-file it into the current default working directory

        system_copy_file(simulink_model_filename, getcwd());
	}

	model->generateRunModelScript(filename_withOut_path, script_filename, output_filename);

    // XXX We do not need tmpSimuFile.  For each iteration, we can concat the iteration result in
    // result_simu_data.txt to simuFileName.
    // Once done, we should remove result_simu_data.txt and tmpSimuFile

	// *************** setting up the mergedFile(s) ***************
	std::string simuFileName = userInputs->getFilenameUnderOutputDirectory("simu.txt");

    fs::remove(simuFileName);
    // *************** mergedFile deleted if exists ***************

	unsigned int matlab_execution_count=0;

	/*
	//std::ofstream finalFile("finalFile.txt",  std::ios_base::binary | std::ios_base::app);
	std::ofstream finalFile(simuFileName,  std::ios_base::binary | std::ios_base::app);

	 for(std::list < std::vector<double> >::iterator it=list_initial_points.begin(); it !=list_initial_points.end(); it++) {
		std::vector<double> init_point = (*it);


		simulate(ep, user, init_point, intermediate); //this will generate the file "result.tsv" for this init_point

		matlab_execution_count++;
		user->setNumberMatlabSimulationExecuted(matlab_execution_count);

		std::string resultFileName = getSimulationOutputFileName(user, intermediate);

		std::ifstream file_a (resultFileName, std::ios_base::binary);

		finalFile.seekp(0, std::ios_base::end);	//seek the record point to end_of_file
		finalFile << file_a.rdbuf();	//append the file_a in the previous file

	}*/
	/*
	 * The above approach gave error while running in our Google Cloud setup but did not show any issues in my Personal Desktop
	 *
	 * So, trying to use simple system command to concate two files into a third file. This will avoid the use of stream operation of C++
	 * ************ cat /home/amit/3dplot.plt /home/amit/amit.java > /home/amit/raj.txt	 ************************
	 */

	//simulation_trace_testing::ptr simu_test = simulation_trace_testing::ptr(new simulation_trace_testing());;

	std::list<std::vector<double> >::iterator it_out_val = initial_output_values.begin(); //iterator for the output variables
	for (std::list<struct timeseries_all_var>::iterator it =initial_simulation_timeSeriesData.begin(); it != initial_simulation_timeSeriesData.end(); it++, it_out_val++) {

		std::list<struct timeseries_input> init_point = (*it).timeseries_signal;

		std::vector<double> output_variable_init_values = (*it_out_val);

		// ***************  --------------------------------- ***************
		simu_model_file(ep, userInputs, init_point, output_variable_init_values, script_filename, output_filename, intermediate, H); //Populate initial data in Matlab's Workspace and then run the script file
		// ***************  --------------------------------- ***************

		std::string resultFileName ="";
		resultFileName.append(getcwd());
		resultFileName.append("/");	//We assume the file "result_simu_data.txt" is generated after each simulation
		resultFileName.append(output_filename);	//We assume the file "result_simu_data.txt" is generated after each simulation

		//cout << "Absolute path of the simulation generated output file: " << resultFileName << endl;

        system_append_file(resultFileName, simuFileName);

		matlab_execution_count++;
		userInputs->setNumberMatlabSimulationExecuted(matlab_execution_count);

		/*if (userInputs->getSimulationCheck()) {	//1 for enabled 0 for disable
			violation_result.total_simulations += 1;
			simu_test->safetyViolationCheck(userInputs, resultFileName, violation_result);
			if (violation_result.foundViolation) {
				break;
			}
		}*/

	} //End of all simulation traces


}
