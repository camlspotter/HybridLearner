/*
 * simulation_utilities.cpp
 *
 *  Created on: 28-Jul-2022
 *      Author: amit
 */

#include "../../utilities/matlab.h"

#include "../../commandLineParser/user_inputs.h"
#include "../../utilities/intermediateResult.h"
#include "../../hybridautomata/hybridAutomata.h"
#include "../../commandLineParser/parameters.h"
#include "../../commandLineParser/user_inputs_helper.h"
#include "../../simulinkModelling/simulinkModelConstructor.h"
#include "../../io_functions/summary.h"
#include "../../io_functions/data_structs.h"
#include <boost/timer/timer.hpp>
#include "../learn_ha/model_setup.h"
#include "../../utilities/linux_utilities.h"
#include "../../utilities/myRandomNumberGenerator.h"
#include "../../utilities/polytope/polytope.h"
#include "../../simulation/simulation.h"

#include "../../utilities/string_operations.h"


/*
 * This function is used in engine:
 * 		simu
 * 		equi-test
 * 		learn-ha-loop
 *
 */
void simu_model_file(std::unique_ptr<MATLABEngine> &ep, user_inputs::ptr &user, std::list<struct timeseries_input> initial_CE_values,
		std::vector<double> &initial_output_values, std::string script_filename,
		std::string output_filename, intermediateResult::ptr &intermediate, hybridAutomata::ptr &ha) {

	//Populate data in the Matlab's Workspace
	for (std::list<struct timeseries_input>::iterator it_values = initial_CE_values.begin(); it_values != initial_CE_values.end(); it_values++) {
		string varName = it_values->var_detail.var_name;
//		std::cout <<"Variable Name=" << varName << std::endl;
		if (user->isInputVariable(varName)) {
			std::string inputDataValues="", inputTimeValue="";
			inputDataValues.append(varName);
			inputDataValues.append("_input");	//Eg.  x0_input

			std::vector<double> cppData = (*it_values).var_values;
//			std::cout <<"cppData.size =" << cppData.size() << std::endl;

			size_t x=1, y=cppData.size();
			matlab::data::ArrayFactory factory;
			auto inputArray = factory.createArray({ x, y }, cppData.cbegin(), cppData.cend());
			//ep->setVariable(u"cp_pedal_angle", inputArray);
			ep->setVariable(convertUTF8StringToUTF16String(inputDataValues), inputArray);

			inputTimeValue.append(varName);
			inputTimeValue.append("_time");	//Eg.  x0_input

			std::vector<double> cppTime = (*it_values).time_values;
			//std::cout <<"Last time of the input variable (cp_pedal_angle) = " << cppTime[cppTime.size()-1] <<endl;
			assert(y == cppTime.size());
			matlab::data::ArrayFactory factory1;
			auto inputArray1 = factory1.createArray({ x, y }, cppTime.cbegin(), cppTime.cend());
			//ep->setVariable(u"timeVector_pedal_angle", inputArray1);
			ep->setVariable(convertUTF8StringToUTF16String(inputTimeValue), inputArray1);

		}
	}

	//use output variables to match only output variables and get the value. Assumed order is maintained even in the initial polytope creation
	assert(initial_output_values.size() == ha->map_size());	//double check

	for (unsigned int index=0; index < ha->map_size(); index++) {
		std::string varName = ha->get_varname(index);
//		std::cout <<"varName:" << varName << " index:" << index << std::endl;
		std::string cmd = "a";
		if (!(user->isInputVariable(varName))) {
			cmd.append(to_string(index));
			cmd.append(" = ");
			cmd.append(to_string(initial_output_values[index]));	//Here the index of initial_output_values include both input and output variables.
			cmd.append(";");
			//modelfile << "a" << index << " = " << initial_output_values[index] ;
			MATLAB_EVAL(ep,cmd);
		}
	}

	unsigned int execution_count = user->getNumberMatlabSimulationExecuted();

	std::string path_user_Model_str="";	//user supplied model

	if (user->getEngine()=="simu") {
//		std::cout<<"cmd = "<< cmd <<std::endl;
		//pathOriginalModel_str = intermediate->getMatlabPathForOriginalModel();
		path_user_Model_str = intermediate->getMatlabPathForLearnedModel();	//todo: we are currently using the learned-model-Interface
	} else if ((user->getEngine()=="learn-ha") || (user->getEngine()=="learn-ha-loop")){
		//std::cout<<"cmd = "<< cmd <<std::endl;
		//pathOriginalModel_str = intermediate->getMatlabPathForOriginalModel();
		path_user_Model_str = intermediate->getMatlabPathForOriginalModel();	//
	} else if (user->getEngine()=="equi-test") {
		path_user_Model_str = intermediate->getMatlabPathForLearnedModel();
	}

	//Removing the files generated by Matlab in the previous run
	if (execution_count == 0) {	//running for the first time

        // cd $path_user_Model_str && rm $output_filename
        {
            std::string cmd = "cd ";
            cmd.append(path_user_Model_str);
            cmd.append(" && rm ");
            cmd.append(output_filename);
            int x = system(cmd.c_str());
            if (x == -1) {
                std::cout <<"Error executing cmd: " << cmd <<std::endl;
            }
        }
		//std::cout <<"before addpath command"<<std::endl;

		//system("cd ../src/benchmark/nav_inst1 && rm result.tsv");	//most important file is result.tsv others I may see later if need arise
		{
            // addpath (genpath('$path_user_Model_str'))
            std::string cmd = "addpath (genpath('";
            cmd.append(path_user_Model_str);
            cmd.append("'))");
            MATLAB_EVAL(ep, cmd);
        }
	}

    // I guess no longer needed
    {
        std::string cmd="cd('";
        cmd.append(path_user_Model_str);
        cmd.append("')");
        MATLAB_EVAL(ep, cmd);
    }

	// Now running the script file that will perform simulation.
	//ep->eval(u"run_script_simu_user_model");	//We assume file generated is "run_script_simu_user_model.m"
	//Extract filename without extension (.m) from script_filename
	MATLAB_RUN(ep, script_filename);
}



/*
 * Variable names need to be handled differently for 1) original and 2) learned model
 * Here initial_CE_values and initial_output_values are having variables names of original model
 */
void simulate_learned_model_from_learn_ha_loop(std::unique_ptr<MATLABEngine> &ep,
                                               user_inputs::ptr &user,
                                               std::list<struct timeseries_input> initial_CE_values,
                                               std::vector<double> &initial_output_values,
                                               std::string script_filename,
                                               std::string output_filename,
                                               intermediateResult::ptr &intermediate,
                                               hybridAutomata::ptr &ha,
                                               model_setup::ptr la_setup)
{

    cout << "simulate_learned_model-from_learn_ha_loop "
         << "script_filename: " << script_filename << " , " 
         << "output_filename: " << output_filename << endl;
        
	//std::cout <<"Let us see the control points" << std::endl;
	//std::cout <<"initial_CE_values.size()=" << initial_CE_values.size() << std::endl;
	//Populate data in the Matlab's Workspace

	std::list<struct variable_mapping> userVariableMapping = la_setup->getUserVariableMapping();

	for (std::list<struct timeseries_input>::iterator it_values = initial_CE_values.begin(); it_values != initial_CE_values.end(); it_values++) {
		string varName = it_values->var_detail.var_name;
		//Find equivalent learned variable name for varName
		//std::cout <<"Input Variable Name=" << varName << std::endl;
		string equi_varName = la_setup->getEquivalentLearnedVariableName(userVariableMapping, varName);
		//std::cout <<"equi_varName Variable Name=" << equi_varName << std::endl;
		varName = equi_varName;

		if (user->isInputVariable(varName)) {
			std::string inputDataValues="", inputTimeValue="";
			inputDataValues.append(varName);
			inputDataValues.append("_input");	//Eg.  x0_input

			std::vector<double> cppData = (*it_values).var_values;
			//std::cout <<"cppData.size =" << cppData.size() << std::endl;

			size_t x=1, y=cppData.size();
			matlab::data::ArrayFactory factory;
			auto inputArray = factory.createArray({ x, y }, cppData.cbegin(), cppData.cend());
			//ep->setVariable(u"cp_pedal_angle", inputArray);
			ep->setVariable(convertUTF8StringToUTF16String(inputDataValues), inputArray);

			inputTimeValue.append(varName);
			inputTimeValue.append("_time");	//Eg.  x0_input

			std::vector<double> cppTime = (*it_values).time_values;
			//std::cout <<"Last time of the input variable (cp_pedal_angle) = " << cppTime[cppTime.size()-1] <<endl;
			assert(y == cppTime.size());
			matlab::data::ArrayFactory factory1;
			auto inputArray1 = factory1.createArray({ x, y }, cppTime.cbegin(), cppTime.cend());
			//ep->setVariable(u"timeVector_pedal_angle", inputArray1);
			ep->setVariable(convertUTF8StringToUTF16String(inputTimeValue), inputArray1);

		}
	}


	//use output variables to match only output variables and get the value. Assumed order is maintained even in the initial polytope creation
	assert(initial_output_values.size() == ha->map_size());	//double check
	for (unsigned int index=0; index < ha->map_size(); index++) {
		std::string varName = ha->get_varname(index);
		//std::cout <<"Variable Name=" << varName << std::endl;
		//std::cout <<"Output varName:" << varName << " index:" << index << std::endl;
		std::string cmd = "a";
		if (!(user->isInputVariable(varName))) {	//since user and ha has some variable mapping, so in any case input variable will not be same as output variable
			cmd.append(to_string(index));
			cmd.append(" = ");
			cmd.append(to_string(initial_output_values[index]));	//Here the index of initial_output_values include both input and output variables.
			cmd.append(";");
			//modelfile << "a" << index << " = " << initial_output_values[index] ;
			MATLAB_EVAL(ep, cmd);
		}
	}

	unsigned int execution_count = user->getNumberMatlabSimulationExecuted();

	std::string path_user_Model_str = intermediate->getMatlabPathForLearnedModel();

	//Removing the files generated by Matlab in the previous run
	if (execution_count == 0) {	//running for the first time

        {
            std::string cmd = "cd ";
            cmd.append(path_user_Model_str);
            cmd.append(" && rm ");
            cmd.append(output_filename);
            int x = system(cmd.c_str());
            if (x == -1) {
                std::cout <<"Error executing cmd: " << cmd <<std::endl;
            }
        }

		{
            std::string cmd = "addpath (genpath('";
            cmd.append(path_user_Model_str);
            cmd.append("'))");
            MATLAB_EVAL(ep, cmd);
        }
	}

	{
        std::string cmd="cd('";
        cmd.append(path_user_Model_str);
        cmd.append("')");
        MATLAB_EVAL(ep, cmd);
    }

	// Now running the script file that will perform simulation.
	MATLAB_RUN(ep, script_filename);
	std::cout << "Done Calling Matlab's simulation on Learned .slx model.\n" << std::endl;

}




void simulate_original_model_from_learn_ha_loop(std::unique_ptr<MATLABEngine> &ep, user_inputs::ptr &user, std::list<struct timeseries_input> initial_CE_values,
		std::vector<double> &initial_output_values, std::string script_filename,
		std::string output_filename, intermediateResult::ptr &intermediate, hybridAutomata::ptr &ha, model_setup::ptr la_setup) {

	//std::cout <<"Let us see the control points" << std::endl;
	//std::cout <<"initial_CE_values.size()=" << initial_CE_values.size() << std::endl;
	//Populate data in the Matlab's Workspace

	std::list<struct variable_mapping> userVariableMapping = la_setup->getUserVariableMapping();

	for (std::list<struct timeseries_input>::iterator it_values = initial_CE_values.begin(); it_values != initial_CE_values.end(); it_values++) {
		string varName = it_values->var_detail.var_name;
		//Find equivalent learned variable name for varName
	//	std::cout <<"Original Variable Name=" << varName << std::endl;

		if (user->isInputVariable(varName)) {
			std::string inputDataValues="", inputTimeValue="";
			inputDataValues.append(varName);
			inputDataValues.append("_input");	//Eg.  x0_input

			std::vector<double> cppData = (*it_values).var_values;
			//std::cout <<"cppData.size =" << cppData.size() << std::endl;

			size_t x=1, y=cppData.size();
			matlab::data::ArrayFactory factory;
			auto inputArray = factory.createArray({ x, y }, cppData.cbegin(), cppData.cend());
			//ep->setVariable(u"cp_pedal_angle", inputArray);
			ep->setVariable(convertUTF8StringToUTF16String(inputDataValues), inputArray);

			inputTimeValue.append(varName);
			inputTimeValue.append("_time");	//Eg.  x0_input

			std::vector<double> cppTime = (*it_values).time_values;
			//std::cout <<"Last time of the input variable (cp_pedal_angle) = " << cppTime[cppTime.size()-1] <<endl;
			assert(y == cppTime.size());
			matlab::data::ArrayFactory factory1;
			auto inputArray1 = factory1.createArray({ x, y }, cppTime.cbegin(), cppTime.cend());
			//ep->setVariable(u"timeVector_pedal_angle", inputArray1);
			ep->setVariable(convertUTF8StringToUTF16String(inputTimeValue), inputArray1);

		}
	}


	//use output variables to match only output variables and get the value. Assumed order is maintained even in the initial polytope creation
	assert(initial_output_values.size() == ha->map_size());	//double check
	for (unsigned int index=0; index < ha->map_size(); index++) {
		std::string varName = ha->get_varname(index);
		//std::cout <<"Variable Name=" << varName << std::endl;
        //	std::cout <<"Original varName:" << varName << " index:" << index << std::endl;
		std::string cmd = "a";
		if (!(user->isInputVariable(varName))) {	//since user and ha has some variable mapping, so in any case input variable will not be same as output variable
			cmd.append(to_string(index));
			cmd.append(" = ");
			cmd.append(to_string(initial_output_values[index]));	//Here the index of initial_output_values include both input and output variables.
			cmd.append(";");
			//modelfile << "a" << index << " = " << initial_output_values[index] ;
			MATLAB_EVAL(ep, cmd);
		}
	}

	unsigned int execution_count = user->getNumberMatlabSimulationExecuted();
	std::string cmd = "cd ";
	//std::string cmd2=" && rm result_simu_data.txt";		//Assuming the data_file generated is "result_simu_data.txt"
	std::string cmd2=" && rm ";		//The data_file generated is output_filename
	cmd2.append(output_filename);

	std::string path_user_Model_str = intermediate->getMatlabPathForOriginalModel(); //path for Original model
	//std::cout <<"path_user_Model_str =" << path_user_Model_str <<std::endl;
	cmd.append(path_user_Model_str);
	cmd.append(cmd2);
	//std::cout << "cmd = " << cmd << std::endl;

	//Removing the files generated by Matlab in the previous run
	if (execution_count == 0) {	//running for the first time

		int x = system(cmd.c_str());
		if (x == -1) {
			std::cout <<"Error executing cmd: " << cmd <<std::endl;
		}
		//system("cd ../src/benchmark/nav_inst1 && rm result.tsv");	//most important file is result.tsv others I may see later if need arise
		cmd="addpath (genpath('";
		cmd.append(path_user_Model_str);
		cmd.append("'))");
		//engEvalString(ep, "addpath (genpath('../src/benchmark/nav_inst1'))"); //currently it is Release or Debug with absolute path
		MATLAB_EVAL(ep, cmd);
	}

	cmd="cd('";
	cmd.append(path_user_Model_str);
	cmd.append("')");
	//engEvalString(ep, "cd('../src/benchmark/nav_inst1')");

    cout << "MATLAB " << cmd << endl;
	MATLAB_EVAL(ep, cmd);

	// Now running the script file that will perform simulation.
	//ep->eval(u"run_script_simu_user_model");	//We assume file generated is "run_script_simu_user_model.m"
	//Extract filename without extension (.m) from script_filename
	size_t found = script_filename.find(".");	//extract file-name from extension
	std::string run_script;
	if (found != string::npos) {
		run_script = script_filename.substr (0,found);
	}
	MATLAB_EVAL(ep, run_script);
	std::cout << "Done Calling Matlab's simulation on Original .slx model.\n" << std::endl;

}




/*
 * This function is called from engine:
 * 		simulation: Here MATLAB engine has not yet started
 *
 */
void generate_input_information(std::list<struct timeseries_all_var> &initial_simulation_timeSeriesData_ret,
		std::list< std::vector<double> > &initial_output_values_ret, parameters::ptr &params, std::unique_ptr<MATLABEngine> &ep, summary::ptr &report){

	user_inputs::ptr userInputs = params->getUserInputs();

	// -------------------    generating input time-serise data   ---------------------
	unsigned int userSeedValue = userInputs->getSeed();
	//std::cout <<"Your Seed Value = " << userSeedValue << std::endl;
	myRandomNumberGenerator::ptr randomGenObject = myRandomNumberGenerator::ptr(new myRandomNumberGenerator(userSeedValue));  // setting 100 as default seed

	params->setRandomGenObj(randomGenObject);

	user_inputs::ptr user_copy = user_inputs::ptr(new user_inputs());
	user_copy = userInputs;
	//toolFrame::ptr toolFrame_for_inputSignal = toolFrame::ptr(new toolFrame(ep, H, user_copy, report, intermediate, randomGenObject));	//Opens a MatLab Engine Connection locally from toolFrame
	std::list<struct timeseries_all_var> initial_simulation_timeSeriesData;
	boost::timer::cpu_timer matlab_start;

//	std::cout << "\nStarting Matlab Engine ... please wait!!" << std::endl;
	matlab_start.start();
	ep = connectMATLAB();
	matlab_start.stop();

	double wall_clock;
	wall_clock = matlab_start.elapsed().wall / 1000000; //convert nanoseconds to milliseconds
	double running_time = wall_clock / (double) 1000;	//convert milliseconds to seconds
//	std::cout << "Matlab engine start: Running Time (in Seconds) = " << running_time << std::endl;
//	temp_report->setRuntimeMatlabStart(running_time);
//	report = temp_report;
	report->setRuntimeMatlabStart(running_time);
	// ---------

	// Creating object of user_inputs_helper class for calling helper functions
	user_inputs_helper::ptr user_inputs_helper_object = user_inputs_helper::ptr(new user_inputs_helper());

	initial_simulation_timeSeriesData = user_inputs_helper_object->generate_input_signals(ep, params);  //create init_poly in this function


//	initial_simulation_timeSeriesData = toolFrame_for_inputSignal->generate_input_signals();  //create init_poly in this function

/*
	// Debug call from equi-test -------------
	std::list<struct timeseries_all_var>::iterator test_it = initial_simulation_timeSeriesData.begin();
	cout << "size=" << (*test_it).timeseries_signal.size();
	// -------------
*/


/*
	//Debug ----
	cout <<"Check-out size=" << initial_simulation_timeSeriesData.size()<< endl;
	for (std::list<struct timeseries_all_var>::iterator it=initial_simulation_timeSeriesData.begin(); it != initial_simulation_timeSeriesData.end(); it++) {
		cout <<"\nData Set Details are " << endl;
		std::list<timeseries_input> time_signal = (*it).timeseries_signal;
		cout <<"Check-out size of time-signal per-simulation =" <<time_signal.size()<< endl;
		for (std::list<struct timeseries_input>::iterator it_in = time_signal.begin(); it_in != time_signal.end(); it_in++) {
			cout <<"Variable Name: " << (*it_in).var_detail.var_name << endl;
			cout <<"Number of CPs: " << (*it_in).var_detail.numberOf_cp << endl;
			vector<double> cp_vector = (*it_in).var_detail.cps;
//			cout <<"CPs are: ";
//			for (unsigned int i=0; i<cp_vector.size(); i++)
//				cout <<cp_vector[i] << "\t";
			cout <<"\nTimeVector are: ";
			for (unsigned int i=0; i<(*it_in).time_values.size(); i++)
				cout <<(*it_in).time_values[i] << "\t";
			cout <<"\nDataVector are: ";
			for (unsigned int i=0; i<(*it_in).var_values.size(); i++)
				cout <<(*it_in).var_values[i] << "\t";
		}
	}
	// ----------
*/


	polytope::ptr initial_poly = params->getInitPoly(); //using init_poly created in the above line. todo: verify if params retains the value of init_poly

//	polytope::ptr initial_poly = toolFrame_for_inputSignal->getInitialPolytope(); //using init_poly created in the above line




//	std::list<struct timeseries_all_var>::iterator it_single_simu = initial_simulation_timeSeriesData.begin();
//	std::list<struct timeseries_input> inputVar_init_point = (*it_single_simu).timeseries_signal;	//here we only have a single simulation, so iteration->begin() is fine.

	unsigned int number_of_traces =1;
	//if ((user_copy->getEngine()=="simu") || (user_copy->getEngine()=="learn-ha")) {
	if ((user_copy->getEngine()=="simu") || (user_copy->getEngine()=="learn-ha")) {
		number_of_traces = user_copy->getSimuInitSize();
	} else if ((user_copy->getEngine()=="equi-test")  || (user_copy->getEngine()=="learn-ha-loop")) {
		unsigned int inti_size = user_copy->getSimuInitSize(), trace_size = user_copy->getMaxTraces();
		if (inti_size > trace_size)	//taking the maximum of the two
			number_of_traces = inti_size;
		else
			number_of_traces = trace_size;
		number_of_traces = user_copy->getMaxGenerateTraceSize();	//todo: Remove: used only for taking reproducible reading
	}



	myRandomNumberGenerator::ptr randomGenObject2 = myRandomNumberGenerator::ptr(new myRandomNumberGenerator(100));  // setting 100 as default seed
//	cout << "number_of_traces = " << number_of_traces << endl;
	//std::list< std::vector<double> > initial_points = getInternalPoints(initial_poly, user_copy->getSimuInitSize(), randomGenObject);
	std::list< std::vector<double> > initial_points = getInternalPoints(initial_poly, number_of_traces, randomGenObject2);

	//-------------------             ---------------------

/*
	// Debug ------------------
	std::cout <<"size:" << initial_points.size() << endl;

	for (std::list< std::vector<double> >::iterator it=initial_points.begin(); it != initial_points.end(); it++) {
		std::vector<double> initial_output_values =  (*it);
		cout <<"Initial Output_variables values = " ;
		for (unsigned int i=0; i < initial_output_values.size(); i++) {
			cout << initial_output_values[i] << "\t";
		}
		cout << endl;
	}
	// ----------------

*/


	initial_simulation_timeSeriesData_ret = initial_simulation_timeSeriesData;
	initial_output_values_ret = initial_points;
}




//runs multiple simulation and creates a trace file.
/*
 * This function is called from engine:
 * 		simulation
 *

 */
void generate_simulation_traces(std::list<struct timeseries_all_var> &initial_simulation_timeSeriesData, std::list<std::vector<double> > &initial_output_values,
		parameters::ptr params, std::unique_ptr<MATLABEngine> &ep) {

	intermediateResult::ptr intermediate = params->getIntermediate();
	user_inputs::ptr userInputs = params->getUserInputs();
	hybridAutomata::ptr H = params->getH();

	//Debug ----
	/*std::cout << "user: sys-dimm="<<userInputs->getSysDimension() <<std::endl;
	std::cout << "user: time-horizon="<<userInputs->getTimeHorizon() <<std::endl;
	std::cout << "user: simu init size="<<userInputs->getSimuInitSize() <<std::endl;
	std::cout << "user: SimulinkModelFilename="<<userInputs->getSimulinkModelFilename() <<std::endl;*/

	// -----

	// ---------- few Path setting for execution to create the .slx model
	std::string current_working_directory = getcwd();
	intermediate->setMatlabDefaultPath(current_working_directory);
	std::string  learned_path ="";
	//cout << "pwd = " << linux_util->getCurrentWorkingDirectoryWithPath() << endl;
	learned_path.append(getcwd()); //either Release or Debug
	intermediate->setMatlabPathForLearnedModel(learned_path);	//todo: currently for 'simu' engine we will use interface for LearnedModel
	// ------------------------------------------------------------------------

	//Step-2: Obtain .slx model from

	simulinkModelConstructor::ptr model = simulinkModelConstructor::ptr(new simulinkModelConstructor(H, userInputs, intermediate));
	unsigned int iterations_count = 0; // just a label for the first model creation
	model->setIteration(iterations_count);	//this may not be required now


	//create_run_script()	//run_script file containing all the variables populated and command to execute the sim of .slx model
	//We assume file generated is "run_script_simu_user_model.m"
	// Now creating script file for later running the simulation and obtaining output-file having fixed time-step
	//Creating a script file for Running the simulink model just created.
	std::string script_filename = "run_script_simu_user_model.m", output_filename="result_simu_data.txt";
	std::string simulink_model_filename = userInputs->getSimulinkModelFilename();

    std::string fullpath = dirname(simulink_model_filename);
    std::string filename_withOut_path = basename(simulink_model_filename);
	if (boost::algorithm::iequals(fullpath, current_working_directory)==false) {
		//fullpath (including user-supplied path) and $PWD are not equal
		//user supplied some relative path along with simulink-model filename. So copy model-file it into the current default working directory

        std::string cmd="cp ";
		cmd.append(simulink_model_filename); //which was stored in the Release folder
		cmd.append(" ");
		cmd.append(current_working_directory);

		int x = system(cmd.c_str());
		if (x == -1) {
			std::cout <<"Error executing cmd: " << cmd <<std::endl;
		}

	}
//	model->create_runScript_for_simu_engine(simulink_model_filename, script_filename, output_filename);
	model->create_runScript_for_simu_engine(filename_withOut_path, script_filename, output_filename);


    // XXX We do not need tmpSimuFile.  For each iteration, we can concat the iteration result in
    // result_simu_data.txt to simuFileName.
    // Once done, we should remove result_simu_data.txt and tmpSimuFile

	// *************** setting up the mergedFile(s) ***************
	std::string simuFileName = userInputs->getFilenameUnderOutputDirectory("simu.txt");
    std::string tmpSimuFile = userInputs->getFilenameUnderOutputDirectory("tmp_simu.txt");

	userInputs->setSimulationFilename(simuFileName);

    // rm $simuFileName $tmpSimuFile
	{
        std::string deleteCommand = "rm ";
        deleteCommand.append(simuFileName);
        deleteCommand.append(" ");
        deleteCommand.append(tmpSimuFile);
        int x = system(deleteCommand.c_str());	//Deleting simu_modelFile.txt and tmp_simu_modelFile.txt. Todo: check if exists before delete
        if (x == -1) {
            std::cout <<"Error executing cmd: " << deleteCommand <<std::endl;
        }
        // *************** mergedFile deleted if exists ***************
    }

	unsigned int matlab_execution_count=0;

	/*
	//std::ofstream finalFile("finalFile.txt",  std::ios_base::binary | std::ios_base::app);
	std::ofstream finalFile(simuFileName,  std::ios_base::binary | std::ios_base::app);

	 for(std::list < std::vector<double> >::iterator it=list_initial_points.begin(); it !=list_initial_points.end(); it++) {
		std::vector<double> init_point = (*it);


		simulate(ep, user, init_point, intermediate); //this will generate the file "result.tsv" for this init_point

		matlab_execution_count++;
		user->setNumberMatlabSimulationExecuted(matlab_execution_count);

		std::string resultFileName = getSimulationOutputFileName(user, intermediate);

		std::ifstream file_a (resultFileName, std::ios_base::binary);

		finalFile.seekp(0, std::ios_base::end);	//seek the record point to end_of_file
		finalFile << file_a.rdbuf();	//append the file_a in the previous file

	}*/
	/*
	 * The above approach gave error while running in our Google Cloud setup but did not show any issues in my Personal Desktop
	 *
	 * So, trying to use simple system command to concate two files into a third file. This will avoid the use of stream operation of C++
	 * ************ cat /home/amit/3dplot.plt /home/amit/amit.java > /home/amit/raj.txt	 ************************
	 */

	//simulation_trace_testing::ptr simu_test = simulation_trace_testing::ptr(new simulation_trace_testing());;

	std::list<std::vector<double> >::iterator it_out_val = initial_output_values.begin(); //iterator for the output variables
	for (std::list<struct timeseries_all_var>::iterator it =initial_simulation_timeSeriesData.begin(); it != initial_simulation_timeSeriesData.end(); it++, it_out_val++) {

		std::list<struct timeseries_input> init_point = (*it).timeseries_signal;

		std::vector<double> output_variable_init_values = (*it_out_val);

		// ***************  --------------------------------- ***************
		simu_model_file(ep, userInputs, init_point, output_variable_init_values, script_filename, output_filename, intermediate, H); //Populate initial data in Matlab's Workspace and then run the script file
		// ***************  --------------------------------- ***************

		std::string resultFileName ="";
		resultFileName.append(intermediate->getMatlabPathForLearnedModel());
		//std::cout <<"check if it is the release folder without end-slash? = " << resultFileName << std::endl;
		//getSimulationOutputFileName(userInputs->getModel(), intermediate->getToolRootPath());
		//resultFileName.append("/result_simu_data.txt");	//We assume the file "result_simu_data.txt" is generated after each simulation
		resultFileName.append("/");	//We assume the file "result_simu_data.txt" is generated after each simulation
		resultFileName.append(output_filename);	//We assume the file "result_simu_data.txt" is generated after each simulation

		//cout << "Absolute path of the simulation generated output file: " << resultFileName << endl;
		/*
		 * cat resultFile > tmpSimuFile //on the 1st iteration
		 * cat  simuFileName  resultFile  >  tmpSimuFile   //from 2nd iteration onwards
		 * cp tmpSimuFile  simuFileName
		 *
		 */

		if (matlab_execution_count==0){	//1st iteration
            std::string cmd="cat ";
			cmd="cat ";
			cmd.append(resultFileName);
			cmd.append(" > ");
			cmd.append(tmpSimuFile);
			//cout <<"Iteration "<< matlab_execution_count <<"  Cmd: " << cmd <<endl;
			int x = system(cmd.c_str());
			if (x == -1) {
				std::cout <<"Error executing cmd: " << cmd <<std::endl;
			}
		} else {	//2nd iterations onwards
            std::string cmd="cat ";
			cmd="cat ";
			cmd.append(simuFileName);
			cmd.append(" ");
			cmd.append(resultFileName);
			cmd.append(" > ");
			cmd.append(tmpSimuFile);
			//cout <<"Iteration "<< matlab_execution_count <<"  Cmd: " << cmd <<endl;
			int x = system(cmd.c_str());
			if (x == -1) {
				std::cout <<"Error executing cmd: " << cmd <<std::endl;
			}
		}

        {
            std::string cmd="cat ";
            cmd="cp ";
            cmd.append(tmpSimuFile);
            cmd.append(" ");
            cmd.append(simuFileName);
            //cout << "  Cmd: " << cmd <<endl;
            int x = system(cmd.c_str());
            if (x == -1) {
                std::cout <<"Error executing cmd: " << cmd <<std::endl;
            }
        }

		matlab_execution_count++;
		userInputs->setNumberMatlabSimulationExecuted(matlab_execution_count);

		/*if (userInputs->getSimulationCheck()) {	//1 for enabled 0 for disable
			violation_result.total_simulations += 1;
			simu_test->safetyViolationCheck(userInputs, resultFileName, violation_result);
			if (violation_result.foundViolation) {
				break;
			}
		}*/

	} //End of all simulation traces


}
