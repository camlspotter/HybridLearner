/*
 * modelParser.cpp
 *
 *  Created on: 22-Sep-2021
 *      Author: amit
 */

#include "../hybridautomata/hybridAutomata.h"
#include "../hybridautomata/location.h"
#include "../hybridautomata/transition.h"
#include "../commandLineParser/user_inputs.h"
#include "../utilities/intermediateResult.h"
#include "../io_functions/summary.h"
#include <boost/algorithm/string.hpp>	//used for trim()

#include <fstream>
#include <iomanip>
#include <string>
#include <sstream>
#include <iostream>
#include "boost/timer/timer.hpp"

std::list<std::string> correctGuard(std::string line1);

std::list<std::string> modify_guard_forNonDeterminism(std::list<std::string> guard, double epsilon, unsigned int sign);
std::list<std::string> modify_guard(std::list<std::string> gurad, unsigned int less_or_greater);
std::list<std::string> modify_guard_asRange(std::list<std::string> gurad, double epsilon);

std::list<std::string> modify_guard_asHalfspace(std::list<std::string> guard, double epsilon);

list<transition::ptr> getAllTrans(unsigned int src, std::vector<transition::ptr> forward, std::vector<transition::ptr> backward);

list<transition::ptr> getAllTrans(unsigned int src, list<transition::ptr>& all_trans);

/*
 * Function for Automata display. Useful for debugging the modelParser()'s correctness
 */
void verifyHA_output(hybridAutomata::ptr &H);

/*
 * Create input-model file for dReach/dReal Tool for Property Verification
 */
void modelConstruction(hybridAutomata::ptr &H, user_inputs::ptr &user, intermediateResult::ptr &intermediate, summary::ptr &report);

/*
 * Function to convert a string (with & as concatenated string) into a list of string.
 * Useful when input_str="x0>=0.344648094532294 & x0<=60.7002246998343 & x1>=905.325240216932 & x1<=1093.21291463544"
 * Output is a list of constraint expression where the separating delimiter is &
 */
std::list<std::string> string2list(std::string input_str);

#include "../dReachModelling/modelConstructor.h"
#include <boost/tokenizer.hpp>

//using namespace boost::algorithm;
using namespace std;

// XXX  Largely duped
//This model-parser function will replace the above two parsing functions
void ha_model_parser(hybridAutomata::ptr &H, user_inputs::ptr &user)
{
	/*
	 * In this approach the learning algorithm creates transitions based on the connecting points and/or user-annotation 
between two modes.
	 * Thus, unlike the above two approaches i.e., one versus one and one versus rest where transitions depends on the number of modes is not the case here.
	 */
	//Has ODE parsing as common code

    string model_filename = user->getFilenameUnderOutputDirectory("learnHA_out.txt"); // XXX define a constant

	string eng_selected = user->getEngine();

	bool modifyGuard;	//modify by default for bbc

	if (eng_selected=="txt2slx") {
		model_filename = user->getModelFilename();
		modifyGuard = user->getGuard();
	} else if  (eng_selected=="learn-ha") {
		modifyGuard = user->getGuard();
	} else {
        //This block is for engine = "bbc" and engine = "learn-ha-loop"
        modifyGuard = true;
	}

	/*
	 * Note:
	 * This modelfile has a specific format generated by the learning algorithm. The syntax and format is as follows:
	 * First line contains File-parameter-information (number-of-modes, number-of-dimension and number-of-transitions)
	 * ---------------------------------------------------------------------------
	 * The SECOND line has the initial starting location-ID as: Example:  Initial-mode 1
	 * ---------------------------------------------------------------------------
	 * Third line onwards contains the mode number-1
	 * Forth line contains the word "inv:"
	 * Fifth line contains the invariant expression
	 * Sixth line contains the word "ODE:"
	 * Seventh line the ODE for this mode for the first variable
	 * Eighth line the ODE for the 2nd variable (assume number-of-dimension=2)
	 * ---------------------------------------------------------------------------
	 * Ninth line contains the mode number-2
	 * Tenth line contains the word "inv:"
	 * Eleventh line contains the invariant expression
	 * Twelfth line contains the word "ODE:"
	 * Thirteenth line contains the ODE for this mode for the first variable
	 * Fourteenth line the ODE for the 2nd variable (assume number-of-dimension=2)
	 * ---------------------------------------------------------------------------

	 * Fifteenth line contain the Transition-Guard number-1
	 * Sixteenth line will contain Transition-Src-Dest	"src-id  =>  dest-id" Example: Transition-Src-Dest	1  =>  2
	 * Seventeenth line will contain the word "guard:"
	 * Eighteenth line will contain the polynomial-guard constraints
	 * Nineteenth line will contain the word "reset:"
	 * Twentieth line onward will contain the reset equation for each variable
	 * .... and so on.
	 *
	 * */

	std::ifstream in(model_filename.c_str()); //This is the file generated by running the Learning Algorithm
    if (!in) {
        std::cout << "Model file '" << model_filename << "' not found, verify if the Learning algorithm worked!!!" << std::endl;
        throw std::runtime_error("Model file " + model_filename + " not found");
	}

	unsigned int tot_modes, tot_dimension, tot_transitions;
    std::string line1;
    std::getline(in, line1); //Reading First Line: Each getline() function will read a line and moves the pointer to the beginning of the next line
    std::istringstream rowInitial(line1);
    //cout<<"Line is "<< line1<<endl;
    rowInitial >> tot_modes; //Reading First value the number-of-modes
    rowInitial >> tot_dimension; //Reading Second value the number-of-dimension
    rowInitial >> tot_transitions; //Reading Third value the number-of-transition-guard

    //cout << "tot_modes = "<<tot_modes<<"  tot_dim="<<tot_dimension <<"   tot_trans="<<tot_transitions <<endl;

    //Shifting the code for Initial Location-ID from the last line to the SECOND line.
    //Reading and setting the Initial ID
    std::getline(in, line1);	//This read is for reading the Initial-Location-ID
    std::istringstream row22(line1);
    //cout<<"Transition Line is "<< line1<<endl;
    string init_label;
    unsigned int init_id;
    row22 >> init_label; //Reading First word of the line1 i.e., the word "Initial-mode"
    row22 >> init_id; //Reading the next word/value i.e., the Initial-Location-ID "1" (say)
    H->setInitialId(init_id);

    //cout <<"Initial Location-ID=" << init_id <<endl;

    std::map<int, location::ptr> map_location_list1, map_location_list2; //mapping of the key loc_id to location::ptr
    //std::map<std::string, int> loc_name_map_id; //here name is used as a Key for ease of search
    //int loc_counter = 1; //loc-Id for key to map_loc_list
    //Reading All Mode's Invariant and ODE
    for (unsigned int i = 1; i <= tot_modes; i++) {	//Modes starts from 1
        location::ptr loc = location::ptr(new location());
        string label_modes;
        int mode_number;

        getline(in , line1);	//This read for reading the mode number
        std::istringstream row1(line1);
        //			cout<<"Line is "<< line1<<endl;
        row1 >> label_modes; //Reading First word of the line1 i.e., the word "mode"
        row1 >> mode_number; //Reading the next word/value i.e., the mode-number "1" (say)
        string mode_name = "mode"+ to_string(mode_number);
        loc->setLocId(mode_number);
        loc->setName(mode_name);


        // ******** Reading Mode Invariant **************
        //   simplified the invariant as a single string of expression. Better parsing and printing from learning-algo can be done later.
        getline(in , line1);	//This read for reading the word "inv:"
        std::istringstream row2(line1);
        //			std::cout<<"Line is "<< line1<<endl;
        std::string word_inv;
        row2 >> word_inv; //Reading the entire invariant expression
        //			std::cout<<"Word inv is "<< word_inv<<endl;

        getline(in , line1);	//This read for reading the invariant expression
        std::istringstream rowInv(line1);
        //			std::string mode_inv_str;
        //			rowInv >> mode_inv_str; //Reading the invariant expression
        std::list<std::string> list_inv;
        //list_inv.push_back(mode_inv_str);
        list_inv = string2list(line1);	//converting the entire inv expression into list of expression
        //list_inv.push_back(lst_inv);
        loc->setInvariant(list_inv);

        // ***********************************************


        // ******** Reading Mode ODE **************
        getline(in , line1);	//This read for reading the word "ODE:"
        std::istringstream row3(line1);
        std::string word_ode;
        row3 >> word_ode; //Reading the entire invariant expression
        //			std::cout<<"Word ODE is "<< word_ode<<endl;

        list<flow_equation> derivatives;

        for (unsigned int j = 0; j < tot_dimension; j++) {
            flow_equation ODEperVariable;
            string LHS, RHS;
            getline(in , line1);	//This read for reading the ODE for each dimension
            ODEperVariable.derivative = line1;
            std::istringstream lhsWord(line1);
            lhsWord >> ODEperVariable.varName; //Note it include the derivative symbol (')
            //				cout <<"ODE line " << line1 <<endl;
            size_t found = line1.find("=");
            if (found != string::npos) {
                //cout << "First occurrence is " << found << endl;
                //RHS = line1.substr (found+1);
                //ODEperVariable.RHSexpression = boost::trim_left(RHS);	//can think about constant dynamics later
                RHS = line1.substr (found+2); //Also left triming a white space
                ODEperVariable.RHSexpression = RHS;	//can think about constant dynamics later
                //cout << RHS << endl;
            } else {
                cout << "Invalid ODE equation found! " << endl;
                throw(new exception());
            }
            derivatives.push_back(ODEperVariable);
        }
        loc->setDerivatives(derivatives);	//First add all the modes without transition and later update the transition.
        map_location_list1[loc->getLocId()] = loc;
        //H->addLocation(loc);

        // ***********************************************
    }
    H->setLocations(map_location_list1);

    location::ptr my_location = location::ptr(new location());
    //my_location = map_location_list1[loc_id];	//accessing from the map data structure to create a new location with same ID and name
    //and fill up the remaining details and replace the hybrid_automata with this new detailed location


    // ******** Reading Transitions **************
    // each transition, has ID, srd: => dest: , guard:, guard expr, word reset:, reset expressions for each variable. Here there is no forward and backward trans

    double epsilon= user->getPrecisionGuardRange();

    //Reading All Transition-Guard:
    //std::vector<transition::ptr> forward(2);	//for mode m==3, we have 3 transitions, K = m * (m - 1)/2
    std::list<transition::ptr> all_transitions;

    for (unsigned int i = 1; i <= tot_transitions; i++) {	//Modes starts from 1

        string label, label_symbol, label_extra;

        transition::ptr trans = transition::ptr(new transition());
        string label_trans;
        unsigned int trans_number;

        getline(in , line1);	//This read for reading the transition number
        std::istringstream row1(line1);
        row1 >> label_trans; //Reading First word of the line1 i.e., the word "Transition-ID"
        row1 >> trans_number; //Reading the next word/value i.e., the Transition-number "1" (say)
        string trans_name = "trans"+ to_string(trans_number);
        trans->setTransId(trans_number);
        trans->setLabel(trans_name);

        unsigned int src, dest;
        std::getline(in, line1);	//This read for reading the word example: "Trans-Src-Dest 1 => 2"
        //cout <<"Trans Line="<<line1<<endl;
        std::istringstream row2(line1);
        row2 >> label_extra; //Reading First word of the line1 i.e., the word "Transition-Src-Dest"
        //cout<<"Transition Src-Dest Label is "<< label<<endl;
        row2 >> src; //Reading the next word/value i.e., the Src-mode-id "1" (say)
        //cout<<"Src = "<<src<<endl;
        row2 >> label_symbol; //Reading First word of the line1 i.e., the word " => "
        //cout<<"Transition Arrow Label is "<< label<<endl;
        row2 >> dest; //Reading the next word/value i.e., the Dest-mode-id "2".
        //cout<<"Dest-1 = "<<dest<<endl;

        trans->setSourceLocationId(src);
        trans->setDestinationLocationId(dest);
        //cout<<"Transition Src "<< trans->getSourceLocationId()<<endl;
        //cout<<"Transition Dest "<< trans->getDestinationLocationId()<<endl;


        // ******** Reading Transition-guard **************

        std::getline(in, line1);	//This read for reading the word "guard:"
        //cout <<"Trans Line="<<line1<<endl;
        std::istringstream row3(line1);
        row3 >> label_extra;
        //			cout<<"word guard = " << label_extra <<endl;

        std::list<std::string> guard;
        std::getline(in, line1);	//This read for reading the polynomial-guard constraints
        guard.push_back(line1);
        //cout<<"Transition Guard line1 is "<< line1<<endl;
        trans->setGuard(guard);

        // ** Working for the Modified Guard to support inequality **
        std::list<std::string> guard_modified;

        if (!modifyGuard) { //user decided not to modify guard
            //trans->setGuardModified(guard);

            //cout <<"guard = " << (*trans->getGuardModified().begin()) <<endl;
            //check if user input "=" then modify to "==" to support Matlab's simulink syntax. This is done only when user decide not to modify guard.
            // Since the correct input symbol in the guard equation is "=" in the model file. But in matlab simulink the correct symbol is "==".
            std::list<std::string> correct_guard;
            correct_guard = correctGuard(line1);
            trans->setGuardModified(correct_guard);
            //cout <<"guard = " << (*trans->getGuardModified().begin()) <<endl;

        } else {	// modify gurad to inequality

            //guard_modified = modify_guard_asRange(guard, epsilon);		//converting to range as inequality. Working with epsilon ERROR

            //Trying to modify guard into halfspace instead of inequality-with-range from hyperplane.
            //Practical observation showed data having src(+1) => dest(-1); gives guard-condition <= 0
            guard_modified = modify_guard_asHalfspace(guard, epsilon);		//converting " = 0" to "<= epsilon". Decision based on SVM's output observation

            trans->setGuardModified(guard_modified);
        }
        // ***********************************************

        // ******** Reading Transition-Reset **************

        std::getline(in, line1);	//This read for reading the word "Reset:"
        //cout <<"Trans Line="<<line1<<endl;
        std::istringstream row4(line1);
        row4 >> label_extra;
        //			cout<<"word reset = " << label_extra <<endl;

        std::list<reset_equation> list_reset;

        for (unsigned int j = 0; j < tot_dimension; j++) {
            reset_equation reset_per_variable;
            string LHS, RHS;
            getline(in , line1);	//This read for reading the reset for each dimension
            reset_per_variable.reset_expression = line1;
            std::istringstream lhsWord(line1);
            lhsWord >> reset_per_variable.varName; //Note it include the prime symbol (')

            size_t found = line1.find("=");
            if (found != string::npos) {
                RHS = line1.substr (found+2); //Also left triming a white space
                reset_per_variable.RHSexpression = RHS;	//can think about constant dynamics later
                //cout << RHS << endl;
            } else {
                cout << "Invalid Reset equation found! " << endl;
                throw(new exception());
            }
            list_reset.push_back(reset_per_variable);
        }
        trans->setAssignment(list_reset);

        // ***********************************************


        all_transitions.push_back(trans);//collecting all the transitions together
    } //End of reading all transitions


    if (tot_modes >= 1 && all_transitions.size() >= 1) {

        std::map<int, location::ptr> list_locations;
        list_locations = H->getLocations();

        //Iterate through all the modes get the mode-id and create list-of-Transitions and add as outGoingTransitions
        for (std::map<int, location::ptr>::iterator i= list_locations.begin(); i != list_locations.end(); i++) {
            location::ptr loc = (*i).second;	//since our location starts from 0
            //cout<<"Location Name: "<<loc->getName() <<"  ID: "<< loc->getLocId()<<endl;
            unsigned int src = loc->getLocId();
            list<transition::ptr> trans = getAllTrans(src, all_transitions);

            my_location = map_location_list1[src];	//i here is the mode-id
            my_location->setOutGoingTransitions(trans);	//the location is now updated with out-going-transition
            map_location_list2[src] = my_location;

        }
        //cout<<"back_trans_ created="<<endl;
    }

    if (tot_modes >= 1 && all_transitions.size() >= 1) { //Modification of Transition is required only for modes > 1
        //cout<<"Total number of Locations (2) ="<<H->getTotalLocations() <<endl;
        H->setLocations(map_location_list2);	//This line is important to update the transitions
    }
    // ***********************************************
	//cout << "Hybrid Automata Object Created ..."<<endl;

	in.close();	//closing the file

}

// Replaces the expression containing "=" into "==", also returns as a list of expression
std::list<std::string> correctGuard(std::string line1){

	//string line1="x0 >= 0.344648094532294";
	//string line1="x0 >= 0.344648094532294 && x0 = 60.7002 && x1 >= 905.32532 && x1 = 1093.212";
	typedef boost::tokenizer<boost::char_separator<char> > tokenizer;
	boost::char_separator<char> sep("&");
	tokenizer tokens(line1, sep);
	list<string> each_guard;
	for (tokenizer::iterator tok_iter = tokens.begin();	tok_iter != tokens.end(); ++tok_iter) {
		string ss = (std::string)(*tok_iter);
		boost::trim(ss);
		each_guard.push_back(ss);
	}


	for (list<string>::iterator it=each_guard.begin(); it != each_guard.end(); it++){
		std::string & the_guard(*it);	//reference
		//cout <<"the_guard:" << the_guard <<endl;
		boost::char_separator<char> sep1(" ");
		tokenizer tokens1(the_guard, sep1);
		unsigned int found=0;
		for (tokenizer::iterator tok_iter1 = tokens1.begin(); tok_iter1 != tokens1.end(); ++tok_iter1) {
			//cout << (*tok_iter1) << endl;
			if ((*tok_iter1) == "="){
				//cout <<"found = sign" <<endl;
				found=1;
			}
		}
		if (found) {
			unsigned int pos = the_guard.find("=");
			string  replacestr1="==";
			//cout <<"token before: " <<(*it) << "  the_guard:" << the_guard << endl;
			the_guard.replace(pos, 1, replacestr1);
			//cout <<"token after: " <<(*it) << "  the_guard:" << the_guard << endl;
		}
	}

	return each_guard;
}


//Take a list<string> of guard and returns list<string> of modified guard and argument a double epsilon value
//Assuming the list of string has only a single string and not a list. TODO: if the guard is not a polynomial equation
std::list<std::string> modify_guard_asRange(std::list<std::string> guard, double epsilon) {
	std::list<std::string> changed_guard;
	///Assuming that the guard is of the form ax+by = 0   Note: THE blank space before and after the zero on the RHS.

	for (std::list<std::string>::iterator gd = guard.begin(); gd != guard.end(); gd++) {
		string str = (*gd);
		std::string search_key (" = ");
		unsigned int guard_length = str.size();
		std::size_t found = str.rfind(&search_key[0], guard_length, 3);	//searching from reverse so position is guard_length and match 3 characters from the search_key in the str

		if (found != std::string::npos) {

		    string str1=str, str2=str, replacestr1=" >= "+to_string(-1 * epsilon)+" + ", replacestr2=" <= "+to_string(epsilon)+" + ";

			str1.replace(found, search_key.length(), replacestr1);
			changed_guard.push_back(str1);

			str2.replace(found, search_key.length(), replacestr2);
			changed_guard.push_back(str2);
		} else { // operator " = " not found so just keep the guard as it is
			changed_guard.push_back(str);
		}

		/*unsigned int pos = str.find("=");
		string str1=str, str2=str, replacestr1=">= "+to_string(-1 * epsilon)+" + ", replacestr2="<= "+to_string(epsilon)+" + ";
		str1.replace(pos, 1, replacestr1);
		changed_guard.push_back(str1);

		str2.replace(pos, 1, replacestr2);
		changed_guard.push_back(str2);*/
	}



	return changed_guard;
}

//Takes a string of guard with "=" symbol and convert it into "<=". This decision is made due to the SVM's output observation
std::list<std::string> modify_guard_asHalfspace(std::list<std::string> guard, double epsilon) {
	std::list<std::string> changed_guard;
	///Assuming that the guard is of the form ax+by = 0   Note: THE blank space before and after the zero on the RHS.

	for (std::list<std::string>::iterator gd = guard.begin(); gd != guard.end(); gd++) {
		string str = (*gd);
		std::string search_key (" = ");
		unsigned int guard_length = str.size();
		std::size_t found = str.rfind(&search_key[0], guard_length, 3);	//searching from reverse so position is guard_length and match 3 characters from the search_key in the str

		if (found != std::string::npos) {

			string str2=str, replacestr2=" <= "+to_string(epsilon)+" + ";
			str2.replace(found, search_key.length(), replacestr2);
			changed_guard.push_back(str2);
		} else { // operator " = " not found so just keep the guard as it is
			changed_guard.push_back(str);
		}
	}

	return changed_guard;
}

//Take a list<string> of guard and returns list<string> of modified guard as epsilon-range value Also ANDing with randomization for non-deterministic transitions
std::list<std::string> modify_guard_forNonDeterminism(std::list<std::string> guard, double epsilon, unsigned int sign) {
	std::list<std::string> changed_guard;
	///Assuming that the guard is of the form ax+by = 0   Note: RHS is 0

	std::list<std::string>::iterator gd = guard.begin();
	string str = (*gd);
	unsigned int pos = str.find("=");
	/*if (less_or_greater == 1)
		str.replace(pos, 1, "<=");
	else if (less_or_greater == 2)
		str.replace(pos, 1, ">=");*/

	string str1=str, str2=str, replacestr1=">= "+to_string(-1 * epsilon)+" + ", replacestr2="<= "+to_string(epsilon)+" + ";
	string str3="";

	str1.replace(pos, 1, replacestr1);
	changed_guard.push_back(str1);

	str2.replace(pos, 1, replacestr2);
	changed_guard.push_back(str2);
	if (sign == 1) //1 for >= 0   and   2 for < 0
		str3 = " myRandomOut() >= 0";
	else
		str3 = " myRandomOut() < 0";
	changed_guard.push_back(str3);

	return changed_guard;
}




//Take a list<string> of guard and returns list<string> of modified guard and argument less_than_equal=1 and greater_than_equal=2
//Assuming the list of string has only a single string and not a list. TODO: if the guard is not a polynomial equation
std::list<std::string> modify_guard(std::list<std::string> gurad, unsigned int less_or_greater) {
	std::list<std::string> changed_guard;

	std::list<std::string>::iterator gd = gurad.begin();
	string str = (*gd);
	unsigned int pos = str.find("=");
	if (less_or_greater == 1)
		str.replace(pos, 1, "<=");
	else if (less_or_greater == 2)
		str.replace(pos, 1, ">=");

	changed_guard.push_back(str);

	return changed_guard;
}


list<transition::ptr> getAllTrans(unsigned int src, std::vector<transition::ptr> forward, std::vector<transition::ptr> backward) {
	list<transition::ptr> trans;
	for (unsigned int i=0; i<forward.size(); i++) {
		if (src == forward[i]->getSourceLocationId()) {
			trans.push_back(forward[i]);
		}
	}
	for (unsigned int i=0; i<backward.size(); i++) {
		if (src==backward[i]->getSourceLocationId()){
			trans.push_back(backward[i]);
		}
	}
	return trans;
}

list<transition::ptr> getAllTrans(unsigned int src, list<transition::ptr>& all_trans) {
	list<transition::ptr> sublist_trans;
	transition::ptr this_trans;

	for (list<transition::ptr>::iterator it=all_trans.begin(); it != all_trans.end(); it++) {
		if (src == (*it)->getSourceLocationId()) {
			this_trans = (*it);
			sublist_trans.push_back(this_trans);
		}
	}

	return sublist_trans;
}


//Function for Debugging the output of HA
void verifyHA_output(hybridAutomata::ptr &H) {


	cout << "*********Verify HA Output*********"<<endl;
	cout << "Total number of Locations = "<< H->getTotalLocations()<<endl;


	H->print_var_mapping();

	cout<< "Initial Location ID: "<< H->getInitialId() <<endl;

	std::map<int, location::ptr> list_locations;
	list_locations = H->getLocations();

	for (std::map<int, location::ptr>::iterator i= list_locations.begin(); i != list_locations.end(); i++) {
		location::ptr loc = (*i).second;	//since our location starts from 0
		cout <<"\n======****** Mode Details ******======"<<endl;
		cout << "Location Name: "<<loc->getName() <<"  ID: "<< loc->getLocId()<<endl;
		std::list<std::string> inv_test = loc->getInvariant();
		for (std::list<std::string>::iterator mod_inv = inv_test.begin(); mod_inv != inv_test.end(); mod_inv++){
			std::cout << "Invariant: " << (*mod_inv) << std::endl;
		}

		list<flow_equation> derivatives = loc->getDerivatives();

		for (list<flow_equation>::iterator it_flow = derivatives.begin(); it_flow != derivatives.end(); it_flow++) {
			std::cout << "Flow: "<<(*it_flow).derivative<< std::endl;
			//cout<<"Flow:varName "<<(*it_flow).varName<<endl;
			//cout<<"Flow:RHS "<<(*it_flow).RHSexpression<<endl;
		}

		list<transition::ptr> trans = loc->getOutGoingTransitions();
		std::cout <<"====== Outgoing transition ======"<< std::endl;
		for (list<transition::ptr>::iterator it_trans = trans.begin(); it_trans != trans.end(); it_trans++) {
			std::cout <<"Transition ID: "<< (*it_trans)->getTransId()<< std::endl;
			std::cout <<"Transition Label: "<< (*it_trans)->getLabel()<< std::endl;
			std::cout <<"Transition Source-ID and Destination-ID:  "<< (*it_trans)->getSourceLocationId() << "  --->   "<< (*it_trans)->getDestinationLocationId()<< std::endl;


			std::list<std::string> guard = (*it_trans)->getGuard();
			list<std::string>::iterator it_guard = guard.begin();
			std::cout<< "Transition-Guard: "<< (*it_guard)<<endl;

			std::list<std::string> guard_modified = (*it_trans)->getGuardModified();
			string guard_changed = (*guard_modified.begin());
			std::cout<< "Transition-Modified Guard: " << std::endl;
			for (std::list<std::string>::iterator mod_guard=guard_modified.begin(); mod_guard != guard_modified.end(); mod_guard++){
				std::cout << (*mod_guard) << std::endl;
			}

			std::cout<< "Transition-Reset: "<< std::endl;
			list<reset_equation> reset_eqs = (*it_trans)->getAssignment();
			for (list<reset_equation>::iterator it_reset = reset_eqs.begin(); it_reset != reset_eqs.end(); it_reset++) {
				std::cout << "Reset: " << (*it_reset).reset_expression << std::endl;
				//cout<<"Reset: varName "<<(*it_reset).varName << endl;
				//cout<<"Reset: RHS "<<(*it_reset).RHSexpression << endl;
			}

		}//End of the Transition
	} //End of the Location

}


void modelConstruction(hybridAutomata::ptr &H, user_inputs::ptr &user, intermediateResult::ptr &intermediate, summary::ptr &report) {
	//*****************************************
    // file_with_path = $outdir/$outdir.drh
	string file_with_path = user->getFilenameUnderOutputDirectory("model.drh");
	//*****************************************

	boost::timer::cpu_timer inputModelCreation;
	inputModelCreation.start();
	//************************************
	modelConstructor::ptr dreachModel = modelConstructor::ptr(new modelConstructor());
	ofstream modelfile;
	modelfile.open(file_with_path);
	if (!modelfile.is_open()) {
		std::cout << "Error opening file: " << file_with_path;
        throw std::runtime_error("Error opening file: " + file_with_path);
    }
    
    std::cout << "\nFile " << file_with_path << " created for Model-Checking using dReach Tool ...\n";
    modelfile << "//Constructing dReach Model-File from tool BBC4CPS";
    modelfile << "\n";
    dreachModel->printModelFile(H, modelfile, user);
	modelfile.close();
	//************************************
	inputModelCreation.stop();
	double wall_clock_modelParser;
	wall_clock_modelParser = inputModelCreation.elapsed().wall / 1000000; //convert nanoseconds to milliseconds
	double running_time = wall_clock_modelParser / (double) 1000;	//convert milliseconds to seconds
	//std::cout << "Model Parsing into Hybrid Automaton: Running Time (in Seconds) = " << running_time<<endl;
	report->setRuntimeInputModelConstruction(running_time);

	std::cout << "\n dReach input-model file created ...\n";
}

/*
 * separates the string into list of string, where separation is done based on "& "
 */
std::list<std::string> string2list(std::string input_str) {
	std::list<std::string> lst_string;
	//input_str="x0>=0.344648094532294 & x0<=60.7002246998343 & x1>=905.325240216932 & x1<=1093.21291463544";
	typedef boost::tokenizer<boost::char_separator<char> > tokenizer;
		boost::char_separator<char> sep("&");
		tokenizer tokens(input_str, sep);
		for (tokenizer::iterator tok_iter = tokens.begin();
				tok_iter != tokens.end(); ++tok_iter) {
			//std::cout << (*tok_iter) << endl;
			string ss = (std::string) (*tok_iter);
			boost::trim(ss);
			//std::cout << ss << endl;
			lst_string.push_back(ss);
		}
	return lst_string;
}
