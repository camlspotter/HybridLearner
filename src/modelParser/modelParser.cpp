/*
 * modelParser.cpp
 *
 *  Created on: 22-Sep-2021
 *      Author: amit
 */

#include "../hybridautomata/hybridAutomata.h"
#include "../hybridautomata/location.h"
#include "../hybridautomata/transition.h"
#include "../commandLineParser/user_inputs.h"
#include "../utilities/intermediateResult.h"
#include "../io_functions/summary.h"
#include <boost/algorithm/string.hpp>	//used for trim()

#include <fstream>
#include <iomanip>
#include <string>
#include <sstream>
#include <iostream>
#include "boost/timer/timer.hpp"

std::list<std::string> correctGuard(std::string line1);

std::list<std::string> modify_guard_forNonDeterminism(std::list<std::string> guard, double epsilon, unsigned int sign);
std::list<std::string> modify_guard(std::list<std::string> gurad, unsigned int less_or_greater);
std::list<std::string> modify_guard_asRange(std::list<std::string> gurad, double epsilon);

std::list<std::string> modify_guard_asHalfspace(std::list<std::string> guard, double epsilon);

list<transition::ptr> getAllTrans(unsigned int src, std::vector<transition::ptr> forward, std::vector<transition::ptr> backward);

list<transition::ptr> getAllTrans(unsigned int src, list<transition::ptr>& all_trans);

/*
 * Function for Automata display. Useful for debugging the modelParser()'s correctness
 */
void verifyHA_output(hybridAutomata::ptr &H);

/*
 * Create input-model file for dReach/dReal Tool for Property Verification
 */
void modelConstruction(hybridAutomata::ptr &H, user_inputs::ptr &user, intermediateResult::ptr &intermediate, summary::ptr &report);

//Test function to read the last word of a file
void readlastWord();


/*
 * Function to convert a string (with & as concatenated string) into a list of string.
 * Useful when input_str="x0>=0.344648094532294 & x0<=60.7002246998343 & x1>=905.325240216932 & x1<=1093.21291463544"
 * Output is a list of constraint expression where the separating delimiter is &
 */
std::list<std::string> string2list(std::string input_str);

#include "../dReachModelling/modelConstructor.h"
#include <boost/tokenizer.hpp>

//using namespace boost::algorithm;
using namespace std;

// NOT USED // This code is not used at all
// NOT USED void modelParser_OneVersusOne(hybridAutomata::ptr &H, user_inputs::ptr &user, intermediateResult::ptr &intermediate) {
// NOT USED 	//This function has common code for parsing ODE, with the function modelParser()
// NOT USED 
// NOT USED 	//	extern  unsigned int log_set;
// NOT USED 	//	std::ofstream log_file("bbc4cps_log_file.txt",  std::ios_base::binary | std::ios_base::app);
// NOT USED 
// NOT USED //		cout << "intermediate->getToolRootPath() = "<<intermediate->getToolRootPath() <<endl;
// NOT USED 
// NOT USED 		//******** Temporary Fix: copying the file generated by learning algorithm to the current directory **********
// NOT USED 		string copycommand ="";
// NOT USED 		copycommand.append("cp ");
// NOT USED 		copycommand.append(intermediate->getToolRootPath());
// NOT USED 		copycommand.append("/src/pwa/");
// NOT USED 		copycommand.append(user->getOutputFilename());
// NOT USED 		copycommand.append(" .");	//to the current working directory, i.e. in the Release directory
// NOT USED 		int x = system(copycommand.c_str());
// NOT USED 		if (x == -1) {
// NOT USED 			cout << "Error executing cmd: " << copycommand << endl;
// NOT USED 		}
// NOT USED 		//******** modelfile now in the current directory **********
// NOT USED 		/*
// NOT USED 		 * Note:
// NOT USED 		 * This modelfile has a specific format generated by the learning algorithm. The syntax and format is as follows:
// NOT USED 		 * First line contains File-parameter-information (number-of-modes, number-of-dimension and number-of-transitions)
// NOT USED 		 * ---------------------------------------------------------------------------
// NOT USED 		 * The SECOND line has the initial starting location-ID as:
// NOT USED 		 * Initial-mode 1
// NOT USED 		 * ---------------------------------------------------------------------------
// NOT USED 		 * Third line onwards contains the mode number-1
// NOT USED 		 * Forth line contains the ODE for this mode for the first variable
// NOT USED 		 * Fifth line the ODE for the 2nd variable (assume number-of-dimension=2)
// NOT USED 		 * ---------------------------------------------------------------------------
// NOT USED 		 * Sixth line contains the mode number-2
// NOT USED 		 * Seventh line contains the ODE for this mode for the first variable
// NOT USED 		 * Eighth line the ODE for the 2nd variable (assume number-of-dimension=2)
// NOT USED 		 * ---------------------------------------------------------------------------
// NOT USED 		 * Ninth line contain the Transition-Guard number-1
// NOT USED 		 * Tenth line contain the polynomial-guard constraints (assume number-of-modes=2)
// NOT USED 		 *
// NOT USED 		 *
// NOT USED 		 *
// NOT USED 		 *
// NOT USED 		 *
// NOT USED 		 *
// NOT USED 		 * So, for 2-modes there is just one Transition-Guard learned by Naijun's implementation
// NOT USED 		 * *************************** (When the learning approach is ONE-VERSUS-ONE): ***************************
// NOT USED 		 * If number of modes(m) and m >= 3, then total number of transitions K = m * (m -1)/ 2. The format is as below
// NOT USED 		 * Tenth line will contain Transition-Src-Dest	"src-id  =>  dest-id" Example:
// NOT USED 		 * Transition-Src-Dest	1  =>  2
// NOT USED 		 * Eleventh line will contain the polynomial-guard constraints
// NOT USED 		 * ----------------------------------
// NOT USED 		 * Twelfth line contain the Transition-Guard number-2
// NOT USED 		 * Thirteenth line contain  Transition-Src-Dest	"src-id  =>  dest-id" Example:
// NOT USED 		 * Transition-Src-Dest	1  =>  3
// NOT USED 		 * Fourteenth line contain the polynomial-guard constraints (assume number-of-modes=3)
// NOT USED 		 * ----------------------------------
// NOT USED 		 * Fifteenth line contain the Transition-Guard number-3
// NOT USED 		 * Sixteenth line contain  Transition-Src-Dest	"src-id  =>  dest-id" Example:
// NOT USED 		 * Transition-Src-Dest	2  =>  3
// NOT USED 		 * Seventeenth line contain the polynomial-guard constraints (assume number-of-modes=3)
// NOT USED 		 * */
// NOT USED 
// NOT USED 		const char* modelfile = user->getOutputFilename().c_str();		//This is the optimized fileName
// NOT USED 		std::ifstream in(modelfile);//This is the file generated by running the Learning Algorithm
// NOT USED 		unsigned int tot_modes, tot_dimension, tot_transitions, tot_trans_oneVsone;
// NOT USED 
// NOT USED 		if (in) {
// NOT USED 			std::string line1;
// NOT USED 			std::getline(in, line1); //Reading First Line: Each getline() function will read a line and moves the pointer to the beginning of the next line
// NOT USED 			std::istringstream row1(line1);
// NOT USED 			//cout<<"Line is "<< line1<<endl;
// NOT USED 			row1 >> tot_modes; //Reading First value the number-of-modes
// NOT USED 			row1 >> tot_dimension; //Reading Second value the number-of-dimension
// NOT USED 			row1 >> tot_transitions; //Reading Third value the number-of-transition-guard
// NOT USED 			tot_trans_oneVsone = tot_modes * (tot_modes - 1) / 2;	//Formula for number of transition, when SVM uses One-Versus-One approach
// NOT USED 			assert(tot_trans_oneVsone == tot_transitions);
// NOT USED 			//cout << "tot_modes = "<<tot_modes<<"  tot_dim="<<tot_dimension <<"   tot_trans="<<tot_transitions <<endl;
// NOT USED 
// NOT USED 			//Shifting the code for Initial Location-ID from the last line to the SECOND line.
// NOT USED 			//Reading and setting the Initial ID
// NOT USED 			std::getline(in, line1);	//This read is for reading the Initial-Location-ID
// NOT USED 			std::istringstream row22(line1);
// NOT USED 			//cout<<"Transition Line is "<< line1<<endl;
// NOT USED 			string init_label;
// NOT USED 			unsigned int init_id;
// NOT USED 			row22 >> init_label; //Reading First word of the line1 i.e., the word "Initial-mode"
// NOT USED 			row22 >> init_id; //Reading the next word/value i.e., the Initial-Location-ID "1" (say)
// NOT USED 			H->setInitialId(init_id);
// NOT USED 
// NOT USED 			//cout <<"Initial Location-ID=" << init_id <<endl;
// NOT USED 
// NOT USED 			std::map<int, location::ptr> map_location_list1, map_location_list2; //mapping of the key loc_id to location::ptr
// NOT USED 			//std::map<std::string, int> loc_name_map_id; //here name is used as a Key for ease of search
// NOT USED 			//int loc_counter = 1; //loc-Id for key to map_loc_list
// NOT USED 			//Reading All Mode's ODE
// NOT USED 			for (unsigned int i = 1; i <= tot_modes; i++) {	//Modes starts from 1
// NOT USED 				location::ptr loc = location::ptr(new location());
// NOT USED 				string label_modes;
// NOT USED 				int mode_number;
// NOT USED 
// NOT USED 				getline(in , line1);	//This read for reading the mode number
// NOT USED 				std::istringstream row1(line1);
// NOT USED 				//cout<<"Line is "<< line1<<endl;
// NOT USED 				row1 >> label_modes; //Reading First word of the line1 i.e., the word "mode"
// NOT USED 				row1 >> mode_number; //Reading the next word/value i.e., the mode-number "1" (say)
// NOT USED 				string mode_name = "mode"+ to_string(mode_number);
// NOT USED 				loc->setLocId(mode_number);
// NOT USED 				loc->setName(mode_name);
// NOT USED 				list<flow_equation> derivatives;
// NOT USED 
// NOT USED 				for (unsigned int j = 0; j < tot_dimension; j++) {
// NOT USED 					flow_equation ODEperVariable;
// NOT USED 					string LHS, RHS;
// NOT USED 					getline(in , line1);	//This read for reading the ODE for each dimension
// NOT USED 					ODEperVariable.derivative = line1;
// NOT USED 					std::istringstream lhsWord(line1);
// NOT USED 					lhsWord >> ODEperVariable.varName; //Note it include the derivative symbol (')
// NOT USED 
// NOT USED 					size_t found = line1.find("=");
// NOT USED 					if (found != string::npos) {
// NOT USED 						//cout << "First occurrence is " << found << endl;
// NOT USED 						//RHS = line1.substr (found+1);
// NOT USED 						//ODEperVariable.RHSexpression = boost::trim_left(RHS);	//can think about constant dynamics later
// NOT USED 						RHS = line1.substr (found+2); //Also left triming a white space
// NOT USED 						ODEperVariable.RHSexpression = RHS;	//can think about constant dynamics later
// NOT USED 						//cout << RHS << endl;
// NOT USED 					} else {
// NOT USED 						cout << "Invalid ODE equation found! " << endl;
// NOT USED 						throw(new exception());
// NOT USED 					}
// NOT USED 					derivatives.push_back(ODEperVariable);
// NOT USED 				}
// NOT USED 				loc->setDerivatives(derivatives);	//First add all the modes without transition and later update the transition.
// NOT USED 				map_location_list1[loc->getLocId()] = loc;
// NOT USED 				//H->addLocation(loc);
// NOT USED 			}
// NOT USED 			H->addMapped_Locations_List(map_location_list1);
// NOT USED 
// NOT USED 			location::ptr my_location = location::ptr(new location());
// NOT USED 			//my_location = map_location_list1[loc_id];	//accessing from the map data structure to create a new location with same ID and name
// NOT USED 			//and fill up the remaining details and replace the hybrid_automata with this new detailed location
// NOT USED 
// NOT USED 
// NOT USED 
// NOT USED 			double epsilon= user->getPrecisionGuardRange();
// NOT USED 
// NOT USED 			//Reading All Transition-Guard:
// NOT USED 			//std::vector<transition::ptr> forward(2);	//for mode m==3, we have 3 transitions, K = m * (m - 1)/2
// NOT USED 			std::vector<transition::ptr> forward(tot_trans_oneVsone);	//for mode==3, we have THREE transitions, considering the above formula due to One-Versus-One approach
// NOT USED 			std::vector<transition::ptr> backward(tot_trans_oneVsone);
// NOT USED 			unsigned int new_transition_Id = 1;
// NOT USED 			unsigned int transition_count=0, trans_back_count=0; //for the extra transition
// NOT USED 			for (unsigned int i = 1; i <= tot_transitions; i++) {
// NOT USED 				string label, label_symbol, label_extra;
// NOT USED 				int transition_id;
// NOT USED 
// NOT USED 
// NOT USED 
// NOT USED 				if (tot_modes > 1) {
// NOT USED 					/*
// NOT USED 					 Steps for handling Transitions:
// NOT USED 					 (1) Read all transition from the learned model-file.
// NOT USED 					 (2) Store these (3) transitions as forward[0], forward[1], and forward[2]
// NOT USED 					 (3) Now, create backward transitions as backward[0], backward[1], and backward[2]
// NOT USED 					 (4) Now, sequentially read the forward and backward transitions and push them to the corresponding modes.
// NOT USED 					 * */
// NOT USED 					std::getline(in, line1);	//This read for reading the Transition-Guard-number
// NOT USED 					std::istringstream row1(line1);
// NOT USED 					//cout<<"Transition Line is "<< line1<<endl;
// NOT USED 
// NOT USED 					row1 >> label; //Reading First word of the line1 i.e., the word "Transition-Guard"
// NOT USED 					row1 >> transition_id; //Reading the next word/value i.e., the transition-number "1" (say)
// NOT USED 					transition::ptr trans = transition::ptr(new transition()) ;
// NOT USED 					//transition::ptr trans2 = transition::ptr(new transition()) ;
// NOT USED 
// NOT USED 					trans->setTransId(transition_id);	//Note transition-id may start with 0, which does not have issue with dReach
// NOT USED 					trans->setLabel(label);
// NOT USED 
// NOT USED 					unsigned int src, dest;
// NOT USED 					std::getline(in, line1);	//This read for reading the Src => Dest
// NOT USED 					//cout <<"Trans Line="<<line1<<endl;
// NOT USED 					std::istringstream row2(line1);
// NOT USED 					row2 >> label_extra; //Reading First word of the line1 i.e., the word "Transition-Src-Dest"
// NOT USED 					//cout<<"Transition Src-Dest Label is "<< label<<endl;
// NOT USED 					row2 >> src; //Reading the next word/value i.e., the Src-mode-id "1" (say)
// NOT USED 					//cout<<"Src = "<<src<<endl;
// NOT USED 					row2 >> label_symbol; //Reading First word of the line1 i.e., the word " => "
// NOT USED 					//cout<<"Transition Arrow Label is "<< label<<endl;
// NOT USED 					row2 >> dest; //Reading the next word/value i.e., the Dest-mode-id "2".
// NOT USED 					//cout<<"Dest-1 = "<<dest<<endl;
// NOT USED 
// NOT USED 
// NOT USED 					trans->setSourceLocationId(src);
// NOT USED 					trans->setDestinationLocationId(dest);
// NOT USED 					//cout<<"Transition Src "<< trans->getSourceLocationId()<<endl;
// NOT USED 					//cout<<"Transition Dest "<< trans->getDestinationLocationId()<<endl;
// NOT USED 
// NOT USED 					std::list<std::string> guard;
// NOT USED 					std::getline(in, line1);	//This read for reading the polynomial-guard constraints
// NOT USED 					guard.push_back(line1);
// NOT USED 					//cout<<"Transition Guard line1 is "<< line1<<endl;
// NOT USED 					trans->setGuard(guard);
// NOT USED 
// NOT USED 					// ************* Working for the Modified Guard to support inequality *************
// NOT USED 					std::list<std::string> guard_modified;
// NOT USED 					guard_modified = modify_guard_asRange(guard, epsilon);		//converting to range as inequality
// NOT USED 					trans->setGuardModified(guard_modified);
// NOT USED 					// ************* *************
// NOT USED 					forward[transition_count] = trans;
// NOT USED 
// NOT USED 
// NOT USED 
// NOT USED 					// For SNDS (switched nonlinear dynamical systems) transition are bi-directional since the state space is divided into two parts
// NOT USED 					transition::ptr back_trans = transition::ptr(new transition());
// NOT USED 					//*********** Creating Backward transitions ******************************
// NOT USED 
// NOT USED 					unsigned int id = tot_transitions + new_transition_Id;	//Giving new transition-Id
// NOT USED 					back_trans->setTransId(id);	//Note transition-id may start with 0, which does not have issue with dReach
// NOT USED 					std::string back_trans_label = trans->getLabel();
// NOT USED 					back_trans_label.append("-back");
// NOT USED 					back_trans->setLabel(back_trans_label);
// NOT USED 					new_transition_Id++;
// NOT USED 
// NOT USED 					back_trans->setSourceLocationId(dest);
// NOT USED 					back_trans->setDestinationLocationId(src);
// NOT USED 					back_trans->setGuard(guard);
// NOT USED 
// NOT USED 					// ************* Working for the Modified Guard to support inequality *************
// NOT USED 					back_trans->setGuardModified(guard_modified);
// NOT USED 					// ************* *************
// NOT USED 					backward[trans_back_count] = back_trans;	//vector indexing from 0 for C++
// NOT USED 
// NOT USED 					transition_count++;
// NOT USED 					trans_back_count++;
// NOT USED 					//*********** forward and backward transitions creation done ******************************
// NOT USED 				} //When mode>1
// NOT USED 
// NOT USED 			} //End of reading all transitions
// NOT USED 
// NOT USED 			if (tot_modes > 1) {
// NOT USED 
// NOT USED 				std::map<int, location::ptr> list_locations;
// NOT USED 				list_locations = H->getLocation_List();
// NOT USED 
// NOT USED 				//Iterate through all the modes get the mode-id and create list-of-Transitions and add as outGoingTransitions
// NOT USED 				for (std::map<int, location::ptr>::iterator i= list_locations.begin(); i != list_locations.end(); i++) {
// NOT USED 					location::ptr loc = (*i).second;	//since our location starts from 0
// NOT USED 					//cout<<"Location Name: "<<loc->getName() <<"  ID: "<< loc->getLocId()<<endl;
// NOT USED 					unsigned int src = loc->getLocId();
// NOT USED 					list<transition::ptr> trans = getAllTrans(src, forward, backward);
// NOT USED 
// NOT USED 					my_location = map_location_list1[src];	//i here is the mode-id
// NOT USED 					my_location->setOutGoingTransitions(trans);	//the location is not updated with out-going-transition
// NOT USED 					map_location_list2[src] = my_location;
// NOT USED 
// NOT USED 				}
// NOT USED 				//cout<<"back_trans_ created="<<endl;
// NOT USED 			}
// NOT USED 
// NOT USED 			if (tot_modes > 1) { //Modification of Transition is required only for modes > 1
// NOT USED 				//cout<<"Total number of Locations (2) ="<<H->getTotalLocations() <<endl;
// NOT USED 				H->addMapped_Locations_List(map_location_list2);	//This line is important to update the transitions
// NOT USED 			}
// NOT USED 
// NOT USED 
// NOT USED 		} //closing in file read-access
// NOT USED }
// NOT USED 
// NOT USED // Implementing model parsing when the learning algorithm implements One-Versus-Rest approach
// NOT USED void modelParser(hybridAutomata::ptr &H, user_inputs::ptr &user, intermediateResult::ptr &intermediate) {
// NOT USED 
// NOT USED //	extern  unsigned int log_set;
// NOT USED //	std::ofstream log_file("bbc4cps_log_file.txt",  std::ios_base::binary | std::ios_base::app);
// NOT USED 
// NOT USED 	cout << "intermediate->getToolRootPath() = "<<intermediate->getToolRootPath() <<endl;
// NOT USED 
// NOT USED 	//******** Temporary Fix: copying the file generated by learning algorithm to the current directory **********
// NOT USED 	string copycommand ="";
// NOT USED 	copycommand.append("cp ");
// NOT USED 	copycommand.append(intermediate->getToolRootPath());
// NOT USED 	copycommand.append("/src/pwa/");
// NOT USED 	copycommand.append(user->getOutputFilename());
// NOT USED 	copycommand.append(" .");	//to the current working directory, i.e. in the Release directory
// NOT USED 	int x = system(copycommand.c_str());
// NOT USED 	if (x == -1) {
// NOT USED 		cout << "Error executing cmd: " << copycommand << endl;
// NOT USED 	}
// NOT USED 	//******** modelfile now in the current directory **********
// NOT USED 	/*
// NOT USED 	 * Note:
// NOT USED 	 * This modelfile has a specific format generated by the learning algorithm. The syntax and format is as follows:
// NOT USED 	 * First line contains File-parameter-information (number-of-modes, number-of-dimension and number-of-transitions)
// NOT USED 	 * ---------------------------------------------------------------------------
// NOT USED 	 * The SECOND line has the initial starting location-ID as:
// NOT USED 	 * Initial-mode 1
// NOT USED 	 * ---------------------------------------------------------------------------
// NOT USED 	 * Third line onwards contains the mode number-1
// NOT USED 	 * Forth line contains the ODE for this mode for the first variable
// NOT USED 	 * Fifth line the ODE for the 2nd variable (assume number-of-dimension=2)
// NOT USED 	 * ---------------------------------------------------------------------------
// NOT USED 	 * Sixth line contains the mode number-2
// NOT USED 	 * Seventh line contains the ODE for this mode for the first variable
// NOT USED 	 * Eighth line the ODE for the 2nd variable (assume number-of-dimension=2)
// NOT USED 	 * ---------------------------------------------------------------------------
// NOT USED 	 * Ninth line contain the Transition-Guard number-1
// NOT USED 	 * Tenth line contain the polynomial-guard constraints (assume number-of-modes=2)
// NOT USED 	 *
// NOT USED 	 * So, for 2-modes there is just one Transition-Guard learned by Naijun's implementation
// NOT USED 	 * *********************************************
// NOT USED 	 * If modes==3, the lines about Modes remains but Transitions one extra line will be added as below (When the learning approach is ONE-VERSUS-REST):
// NOT USED 	 * Tenth line will contain Transition-Src-Dest	"src-id  =>  dest-id" Example:
// NOT USED 	 * Transition-Src-Dest	0  =>  1,2
// NOT USED 	 * Eleventh line will contain the polynomial-guard constraints
// NOT USED 	 * ----------------------------------
// NOT USED 	 * Twelfth line contain the Transition-Guard number-2
// NOT USED 	 * Thirteenth line contain  Transition-Src-Dest	"src-id  =>  dest-id"
// NOT USED 	 * Fourteenth line contain the polynomial-guard constraints (assume number-of-modes=3)
// NOT USED 	 * ----------------------------------
// NOT USED 	 *
// NOT USED 	 * */
// NOT USED 
// NOT USED 	const char* modelfile = user->getOutputFilename().c_str();		//This is the optimized fileName
// NOT USED 	std::ifstream in(modelfile);//This is the file generated by running the Learning Algorithm
// NOT USED 	int tot_modes, tot_dimension, tot_transitions;
// NOT USED 
// NOT USED     if (!in) {
// NOT USED         std::cout << "Model file '" << user->getOutputFilename() << "' not found, verify if the Learning algorithm worked!!!" << std::endl;
// NOT USED         throw std::runtime_error("Model file not found");
// NOT USED 	}
// NOT USED 
// NOT USED     std::string line1;
// NOT USED     std::getline(in, line1); //Reading First Line: Each getline() function will read a line and moves the pointer to the beginning of the next line
// NOT USED     std::istringstream row1(line1);
// NOT USED     //cout<<"Line is "<< line1<<endl;
// NOT USED     row1 >> tot_modes; //Reading First value the number-of-modes
// NOT USED     row1 >> tot_dimension; //Reading Second value the number-of-dimension
// NOT USED     row1 >> tot_transitions; //Reading Third value the number-of-transition-guard
// NOT USED     assert(tot_modes == (tot_transitions + 1));
// NOT USED     //cout << "tot_modes = "<<tot_modes<<"  tot_dim="<<tot_dimension <<"   tot_trans="<<tot_transitions <<endl;
// NOT USED     //		if (log_set){
// NOT USED     //			log_file << "tot_modes = "<<tot_modes<<"  tot_dim="<<tot_dimension <<"   tot_trans="<<tot_transitions <<endl;
// NOT USED     //		}
// NOT USED 
// NOT USED     //Shifting the code for Initial Location-ID from the last line to the SECOND line.
// NOT USED     //Reading and setting the Initial ID
// NOT USED     std::getline(in, line1);	//This read is for reading the Initial-Location-ID
// NOT USED     std::istringstream row22(line1);
// NOT USED     //cout<<"Transition Line is "<< line1<<endl;
// NOT USED     string init_label;
// NOT USED     unsigned int init_id;
// NOT USED     row22 >> init_label; //Reading First word of the line1 i.e., the word "Initial-mode"
// NOT USED     row22 >> init_id; //Reading the next word/value i.e., the Initial-Location-ID "1" (say)
// NOT USED     H->setInitialId(init_id);
// NOT USED 
// NOT USED     //cout <<"Initial Location-ID=" << init_id <<endl;
// NOT USED 
// NOT USED     std::map<int, location::ptr> map_location_list1, map_location_list2; //mapping of the key loc_id to location::ptr
// NOT USED     //std::map<std::string, int> loc_name_map_id; //here name is used as a Key for ease of search
// NOT USED     //int loc_counter = 1; //loc-Id for key to map_loc_list
// NOT USED     //Reading All Mode's ODE
// NOT USED     for (int i = 1; i <= tot_modes; i++) {	//Modes starts from 1
// NOT USED         location::ptr loc = location::ptr(new location());
// NOT USED         string label_modes;
// NOT USED         int mode_number;
// NOT USED 
// NOT USED         getline(in , line1);	//This read for reading the mode number
// NOT USED         std::istringstream row1(line1);
// NOT USED         //cout<<"Line is "<< line1<<endl;
// NOT USED         row1 >> label_modes; //Reading First word of the line1 i.e., the word "mode"
// NOT USED         row1 >> mode_number; //Reading the next word/value i.e., the mode-number "1" (say)
// NOT USED         string mode_name = "mode"+ to_string(mode_number);
// NOT USED         loc->setLocId(mode_number);
// NOT USED         loc->setName(mode_name);
// NOT USED         list<flow_equation> derivatives;
// NOT USED 
// NOT USED         for (int j = 0; j < tot_dimension; j++) {
// NOT USED             flow_equation ODEperVariable;
// NOT USED             string LHS, RHS;
// NOT USED             getline(in , line1);	//This read for reading the ODE for each dimension
// NOT USED             ODEperVariable.derivative = line1;
// NOT USED             std::istringstream lhsWord(line1);
// NOT USED             lhsWord >> ODEperVariable.varName; //Note it include the derivative symbol (')
// NOT USED 
// NOT USED             size_t found = line1.find("=");
// NOT USED             if (found != string::npos) {
// NOT USED                 //cout << "First occurrence is " << found << endl;
// NOT USED                 //RHS = line1.substr (found+1);
// NOT USED                 //ODEperVariable.RHSexpression = boost::trim_left(RHS);	//can think about constant dynamics later
// NOT USED                 RHS = line1.substr (found+2); //Also left triming a white space
// NOT USED                 ODEperVariable.RHSexpression = RHS;	//can think about constant dynamics later
// NOT USED                 //cout << RHS << endl;
// NOT USED             } else {
// NOT USED                 cout << "Invalid ODE equation found! " << endl;
// NOT USED                 //					if (log_set){
// NOT USED                 //						log_file << "Invalid ODE equation found! " << endl;
// NOT USED                 //					}
// NOT USED                 throw(new exception());
// NOT USED             }
// NOT USED             derivatives.push_back(ODEperVariable);
// NOT USED         }
// NOT USED         loc->setDerivatives(derivatives);	//First add all the modes without transition and later update the transition.
// NOT USED         map_location_list1[loc->getLocId()] = loc;
// NOT USED         //H->addLocation(loc);
// NOT USED     }
// NOT USED     H->addMapped_Locations_List(map_location_list1);
// NOT USED 
// NOT USED     location::ptr my_location = location::ptr(new location());
// NOT USED     //my_location = map_location_list1[loc_id];	//accessing from the map data structure to create a new location with same ID and name
// NOT USED     //and fill up the remaining details and replace the hybrid_automata with this new detailed location
// NOT USED 
// NOT USED 
// NOT USED 
// NOT USED 
// NOT USED 
// NOT USED 
// NOT USED 
// NOT USED     double epsilon= user->getPrecisionGuardRange();
// NOT USED 
// NOT USED     //Reading All Transition-Guard:    Note: "Transition's Guard modified-inequality sign will depend on the initial-location"
// NOT USED     //std::vector<transition::ptr> forward(2);	//for mode==3, we have two transitions
// NOT USED     std::vector<transition::ptr> forward(3);	//for mode==3, we have THREE transitions, considering the class {1} ==> {2,3} as two transitions
// NOT USED     std::vector<transition::ptr> backward(3);
// NOT USED     unsigned int new_transition_Id = 1;
// NOT USED     unsigned int dest2, transition_count=0, trans_back_count=0; //for the extra transition
// NOT USED     for (int i = 1; i <= tot_transitions; i++) {
// NOT USED         string label, label_symbol, label_extra;
// NOT USED         int transition_id;
// NOT USED 
// NOT USED         if (tot_modes==2) {
// NOT USED             /*
// NOT USED              * Note: The output-file which is being parsed has the format as described above.
// NOT USED              * Moreover, the Mode-ID starts from 1.
// NOT USED              */
// NOT USED             std::getline(in, line1);	//This read for reading the Transition-Guard-number
// NOT USED             std::istringstream row1(line1);
// NOT USED             //cout<<"Transition Line is "<< line1<<endl;
// NOT USED 
// NOT USED             row1 >> label; //Reading First word of the line1 i.e., the word "Transition-Guard"
// NOT USED             row1 >> transition_id; //Reading the next word/value i.e., the transition-number "0" (say)
// NOT USED             transition::ptr trans = transition::ptr(new transition()) ;
// NOT USED             trans->setTransId(transition_id);	//Note transition-id may start with 0, which does not have issue with dReach
// NOT USED             trans->setLabel(label);
// NOT USED             trans->setSourceLocationId(i);//i equals mode-id Note: here First Transition will go to the first Mode, 2nd with the 2nd Mode.
// NOT USED             trans->setDestinationLocationId(i+1);//Note here First Transition will go to the first Mode, 2nd with the 2nd Mode.
// NOT USED             //cout<<"Transition Label is "<< trans->getLabel()<<endl;
// NOT USED 
// NOT USED             std::list<std::string> guard;
// NOT USED             std::getline(in, line1);	//This read the polynomial-guard constraints "with equal to 0"
// NOT USED             guard.push_back(line1);
// NOT USED             //cout<<"Transition Guard line1 is "<< line1<<endl;
// NOT USED             trans->setGuard(guard);
// NOT USED 
// NOT USED             // ************* Working for the Modified Guard to support inequality *************
// NOT USED             std::list<std::string> guard_modified;
// NOT USED             //****** whether forward or backward is decided by if (Initial-location-ID == src-ID) then transition is forward(<=). even better use the hyperplane_to_halfspace function
// NOT USED             /*if (trans->getSourceLocationId() == init_id) {
// NOT USED               guard_modified = modify_guard(guard, 1);
// NOT USED               } else {
// NOT USED               guard_modified = modify_guard(guard, 2);
// NOT USED               }
// NOT USED               trans->setGuardModified(guard_modified);*/
// NOT USED             // ************* *************
// NOT USED             guard_modified = modify_guard_asRange(guard, epsilon);	//The range is -epsilon to +epsilon; which means 2*epsilon gap
// NOT USED             trans->setGuardModified(guard_modified); //Best is to convert "equality to a range by +/- epsilon value"
// NOT USED 
// NOT USED             list<transition::ptr> trans_list;
// NOT USED             trans_list.push_back(trans);
// NOT USED             //Note here First Transition will go to the first Mode, 2nd with the 2nd Mode.
// NOT USED             my_location = map_location_list1[i];	//i here is the mode-id
// NOT USED             //H->getLocation(transition_id)->setOutGoingTransitions(trans_list);//I hope this updates the transition of the location in the hybrid automata. NO THIS WAY UPDATE DID NOT WORK.
// NOT USED             my_location->setOutGoingTransitions(trans_list);	//the location is not updated with out-going-transition
// NOT USED             map_location_list2[i] = my_location;
// NOT USED 
// NOT USED         }
// NOT USED 
// NOT USED         if (tot_modes==3) {
// NOT USED             /*
// NOT USED               Steps for handling Transitions:
// NOT USED               (1) Read all transition from the learned model-file.
// NOT USED               (2) Store these (2) transitions as forward[0] and forward[1]
// NOT USED               (3) Now, create backward transitions as backward[0] and backward[1]
// NOT USED               (4) Now, sequentially read the forward and backward transitions and push them to the corresponding modes.
// NOT USED               * */
// NOT USED             std::getline(in, line1);	//This read for reading the Transition-Guard-number
// NOT USED             std::istringstream row1(line1);
// NOT USED             //cout<<"Transition Line is "<< line1<<endl;
// NOT USED 
// NOT USED             row1 >> label; //Reading First word of the line1 i.e., the word "Transition-Guard"
// NOT USED             row1 >> transition_id; //Reading the next word/value i.e., the transition-number "0" (say)
// NOT USED             transition::ptr trans = transition::ptr(new transition()) ;
// NOT USED             transition::ptr trans2 = transition::ptr(new transition()) ;
// NOT USED 
// NOT USED             trans->setTransId(transition_id);	//Note transition-id may start with 0, which does not have issue with dReach
// NOT USED             trans->setLabel(label);
// NOT USED 
// NOT USED             unsigned int src, dest;
// NOT USED             std::getline(in, line1);	//This read for reading the Src => Dest
// NOT USED             //cout <<"Trans Line="<<line1<<endl;
// NOT USED             std::istringstream row2(line1);
// NOT USED             row2 >> label_extra; //Reading First word of the line1 i.e., the word "Transition-Src-Dest"
// NOT USED             //cout<<"Transition Src-Dest Label is "<< label<<endl;
// NOT USED             row2 >> src; //Reading the next word/value i.e., the Src-mode-id "1" (say)
// NOT USED             //cout<<"Src = "<<src<<endl;
// NOT USED             row2 >> label_symbol; //Reading First word of the line1 i.e., the word " => "
// NOT USED             //cout<<"Transition Arrow Label is "<< label<<endl;
// NOT USED             row2 >> dest; //Reading the next word/value i.e., the Dest-mode-id "2".
// NOT USED             //cout<<"Dest-1 = "<<dest<<endl;
// NOT USED 
// NOT USED             if (i==1) { //1st transition has "syntax:   1 => 2 , 3
// NOT USED                 //Although dest can be  2 , 3 but only 2 is/was taken. TODO (need to understand)
// NOT USED                 row2 >> label_symbol; //Reading First word of the line1 i.e., the word " , "
// NOT USED                 //cout<<"should be , = " << label_symbol <<endl;
// NOT USED                 row2 >> dest2; //Reading the next word/value i.e., the Dest-mode-id "3".
// NOT USED                 //cout<<"Dest-2 = "<<dest2<<endl;
// NOT USED             }
// NOT USED 
// NOT USED             trans->setSourceLocationId(src);
// NOT USED             trans->setDestinationLocationId(dest);
// NOT USED             //cout<<"Transition Src "<< trans->getSourceLocationId()<<endl;
// NOT USED             //cout<<"Transition Dest "<< trans->getDestinationLocationId()<<endl;
// NOT USED 
// NOT USED             std::list<std::string> guard;
// NOT USED             std::getline(in, line1);	//This read for reading the polynomial-guard constraints
// NOT USED             guard.push_back(line1);
// NOT USED             //cout<<"Transition Guard line1 is "<< line1<<endl;
// NOT USED             trans->setGuard(guard);
// NOT USED             transition_count++;
// NOT USED 
// NOT USED             // ************* Working for the Modified Guard to support inequality *************
// NOT USED             std::list<std::string> guard_modified;
// NOT USED             //guard_modified = modify_guard(guard, 1); //Reactivating
// NOT USED             if (i==1)
// NOT USED                 guard_modified = modify_guard_forNonDeterminism(guard, epsilon, 1);		//converting to range as inequality and Anding with randomization. sign can be 1 (>=0) or 2 (<0)
// NOT USED             else
// NOT USED                 guard_modified = modify_guard_asRange(guard, epsilon);		//converting to range as inequality
// NOT USED 
// NOT USED             trans->setGuardModified(guard_modified);
// NOT USED             // ************* *************
// NOT USED 
// NOT USED             //forward[i-1] = trans;	//vector indexing from 0 for C++
// NOT USED             forward[transition_count - 1] = trans;	//vector indexing from 0 for C++
// NOT USED 
// NOT USED             if (i==1) { //1st transition has "syntax:   1 => 2 , 3
// NOT USED 
// NOT USED                 int id2 = tot_transitions + new_transition_Id;	//Giving new transition-Id
// NOT USED                 new_transition_Id++;
// NOT USED                 trans2->setTransId(id2);	//Note transition-id may start with 0, which does not have issue with dReach
// NOT USED                 trans2->setLabel(label);
// NOT USED 
// NOT USED                 trans2->setSourceLocationId(src);
// NOT USED                 trans2->setDestinationLocationId(dest2);
// NOT USED                 transition_count++;
// NOT USED                 trans2->setGuard(guard);
// NOT USED 
// NOT USED                 // ************* Working for the Modified Guard to support inequality *************
// NOT USED                 guard_modified = modify_guard_forNonDeterminism(guard, epsilon, 2);		//converting to range as inequality and Anding with randomization. sign can be 1 (>=0) or 2 (<0)
// NOT USED                 trans2->setGuardModified(guard_modified);	//same modification converting to range as inequality
// NOT USED                 // ************* *************
// NOT USED                 forward[transition_count - 1] = trans2;	//vector indexing from 0 for C++
// NOT USED             }
// NOT USED 
// NOT USED             // For SNDS (switched nonlinear dynamical systems) transition are bi-directional since the state space is divided
// NOT USED             transition::ptr back_trans = transition::ptr(new transition());
// NOT USED 
// NOT USED             int id = tot_transitions + new_transition_Id;	//Giving new transition-Id
// NOT USED             back_trans->setTransId(id);	//Note transition-id may start with 0, which does not have issue with dReach
// NOT USED             std::string back_trans_label = trans->getLabel();
// NOT USED             back_trans_label.append("-back");
// NOT USED             back_trans->setLabel(back_trans_label);
// NOT USED             new_transition_Id++;
// NOT USED 
// NOT USED             back_trans->setSourceLocationId(dest);
// NOT USED             back_trans->setDestinationLocationId(src);
// NOT USED             back_trans->setGuard(guard);
// NOT USED             trans_back_count++;
// NOT USED 
// NOT USED             // ************* Working for the Modified Guard to support inequality *************
// NOT USED             std::list<std::string> guard_modified_back;
// NOT USED             //guard_modified_back = modify_guard(guard, 2);	//This is the backward transition (so use >= guard). Argument value 1 for <= and 2 for >=
// NOT USED 
// NOT USED             guard_modified_back = modify_guard_asRange(guard, epsilon);
// NOT USED 
// NOT USED             back_trans->setGuardModified(guard_modified_back);
// NOT USED             // ************* *************
// NOT USED 
// NOT USED             //backward[i-1] = back_trans;	//vector indexing from 0 for C++
// NOT USED             backward[trans_back_count - 1] = back_trans;	//vector indexing from 0 for C++
// NOT USED 
// NOT USED             if (i==1) { //1st transition has "syntax:   1 => 2 , 3
// NOT USED                 transition::ptr back_trans2 = transition::ptr(new transition());
// NOT USED                 int id2_back = tot_transitions + new_transition_Id;	//Giving new transition-Id
// NOT USED                 new_transition_Id++;
// NOT USED 
// NOT USED                 back_trans2->setTransId(id2_back);	//Note transition-id may start with 0, which does not have issue with dReach
// NOT USED                 std::string back_trans_label2 = trans2->getLabel();
// NOT USED                 back_trans_label2.append("-back");
// NOT USED                 back_trans2->setLabel(back_trans_label2);
// NOT USED 
// NOT USED                 back_trans2->setSourceLocationId(dest2);
// NOT USED                 back_trans2->setDestinationLocationId(src);
// NOT USED                 back_trans2->setGuard(guard);
// NOT USED                 trans_back_count++;
// NOT USED 
// NOT USED                 // ************* Working for the Modified Guard to support inequality *************
// NOT USED                 std::list<std::string> guard_modified_back;
// NOT USED                 //guard_modified_back = modify_guard(guard, 2);	//This is the backward transition (so use >= guard). Argument value 1 for <= and 2 for >=
// NOT USED 
// NOT USED                 guard_modified_back = modify_guard_asRange(guard, epsilon);
// NOT USED                 back_trans2->setGuardModified(guard_modified_back);
// NOT USED                 // ************* *************
// NOT USED                 backward[trans_back_count - 1] = back_trans2;	//vector indexing from 0 for C++
// NOT USED             }
// NOT USED             //*********** forward and backward transitions creation done ******************************
// NOT USED         } //When mode==3
// NOT USED     } //End of reading all Transition
// NOT USED 
// NOT USED     //cout<<"Total number of Locations ="<<H->getTotalLocations() <<endl;
// NOT USED     if (tot_modes == 2) {
// NOT USED         //This section to get create a Backward Transition
// NOT USED         //cout<<"Total number of Locations = 2"<<endl;
// NOT USED         location::ptr previous_location = location::ptr(new location());
// NOT USED         list<transition::ptr> previous_trans_list, next_trans_list;// = transition::ptr(new transition()) ;
// NOT USED         previous_location = map_location_list1[1];	//Location's ID starts from 1. TODO use previous_loc_id
// NOT USED         previous_trans_list = previous_location->getOutGoingTransitions();
// NOT USED 
// NOT USED         transition::ptr back_transition = transition::ptr (new transition());
// NOT USED         transition::ptr previous_trans = transition::ptr (new transition());
// NOT USED         list<transition::ptr>::iterator it_trans = previous_trans_list.begin();
// NOT USED         previous_trans =  (*it_trans);
// NOT USED 
// NOT USED         std::string back_trans_label = "";
// NOT USED         back_trans_label.append(previous_trans->getLabel().c_str());
// NOT USED         back_trans_label.append("-back");
// NOT USED         back_transition->setLabel(back_trans_label);
// NOT USED 
// NOT USED         int id = tot_transitions;	//Giving new transition-Id (which is 1)
// NOT USED         back_transition->setTransId(id);
// NOT USED         back_transition->setSourceLocationId(2);	//Here 2 is the 2nd Mode, which is now the source.
// NOT USED         back_transition->setDestinationLocationId(1);	//Here 1 is the 1st Mode, which is the destination for back-transition.
// NOT USED 
// NOT USED         std::list<std::string> guard_list = previous_trans->getGuard();
// NOT USED         //std::list<std::string>::iterator it_guard = guard_list.begin();
// NOT USED         back_transition->setGuard(guard_list);
// NOT USED 
// NOT USED         // ************* Working for the Modified Guard to support inequality *************
// NOT USED         std::list<std::string> guard_modified_back;
// NOT USED 
// NOT USED         //****** whether forward or backward is decided by if (Initial-location-ID == src-ID) then transition is forward(<=)
// NOT USED         /*if (back_transition->getSourceLocationId() == init_id) {
// NOT USED           guard_modified_back = modify_guard(guard_list, 1);
// NOT USED           } else {
// NOT USED           guard_modified_back = modify_guard(guard_list, 2);
// NOT USED           }
// NOT USED           back_transition->setGuardModified(guard_modified_back);*/
// NOT USED         // ************* *************
// NOT USED 
// NOT USED         guard_modified_back = modify_guard_asRange(guard_list, epsilon);	//The range is -epsilon to +epsilon; which means 2*epsilon gap
// NOT USED         back_transition->setGuardModified(guard_modified_back); //Best is to convert "equality to a range by +/- epsilon value"
// NOT USED 
// NOT USED         next_trans_list.push_back(back_transition);
// NOT USED 
// NOT USED         my_location = map_location_list1[2];	//last location
// NOT USED         my_location->setOutGoingTransitions(next_trans_list);
// NOT USED 
// NOT USED         map_location_list2[2] = my_location;	//Here no modification to my_location, since last location does not have transition
// NOT USED 
// NOT USED     }  else if (tot_modes == 3) {
// NOT USED 
// NOT USED         std::map<int, location::ptr> list_locations;
// NOT USED         list_locations = H->getLocation_List();
// NOT USED 
// NOT USED         //Iterate through all the modes get the mode-id and create list-of-Transitions and add as outGoingTransitions
// NOT USED         for (std::map<int, location::ptr>::iterator i= list_locations.begin(); i != list_locations.end(); i++) {
// NOT USED             location::ptr loc = (*i).second;	//since our location starts from 0
// NOT USED             //cout<<"Location Name: "<<loc->getName() <<"  ID: "<< loc->getLocId()<<endl;
// NOT USED             unsigned int src = loc->getLocId();
// NOT USED             list<transition::ptr> trans = getAllTrans(src, forward, backward);
// NOT USED 
// NOT USED             my_location = map_location_list1[src];	//i here is the mode-id
// NOT USED             //H->getLocation(transition_id)->setOutGoingTransitions(trans_list);//I hope this updates the transition of the location in the hybrid automata. NO THIS WAY UPDATE DID NOT WORK.
// NOT USED             my_location->setOutGoingTransitions(trans);	//the location is not updated with out-going-transition
// NOT USED             map_location_list2[src] = my_location;
// NOT USED 
// NOT USED         }
// NOT USED 
// NOT USED         //cout<<"back_trans_ created="<<endl;
// NOT USED     } else if (tot_modes > 3) {
// NOT USED         std::cout << "\nMissing implementation for Mode/Location > 3!!!" << std::endl;
// NOT USED         //			if (log_set){
// NOT USED         //				log_file << "\nMissing implementation for Mode/Location > 3!!!" << std::endl;
// NOT USED         //			}
// NOT USED         throw(new exception());
// NOT USED     }
// NOT USED     if (tot_modes > 1) { //Modification of Transition is required only for modes > 1
// NOT USED         //cout<<"Total number of Locations (2) ="<<H->getTotalLocations() <<endl;
// NOT USED         H->addMapped_Locations_List(map_location_list2);	//This line is important to update the transitions
// NOT USED     }
// NOT USED 
// NOT USED     //*********** Adding the variable to index mapping in the Automata ***********
// NOT USED     //Get any one of the Location and traverse through the flow_equation and get the LHS of the ODE
// NOT USED     location::ptr loc1 = location::ptr(new location());
// NOT USED     loc1 = map_location_list1[1];	//First location; can also use map_location_list2 or H->getLocation(1)
// NOT USED     list<flow_equation> ode = loc1->getDerivatives();
// NOT USED     int counter=0;
// NOT USED     for (list<flow_equation>::iterator it_ode = ode.begin(); it_ode != ode.end(); it_ode++) {
// NOT USED         string variableName = (*it_ode).varName;	//eg x0'
// NOT USED         size_t pos = variableName.find("'");
// NOT USED         variableName = variableName.substr(0, pos);	//extract only the variable name and not the derivative symbol
// NOT USED         H->insert_to_map(variableName, counter);
// NOT USED         counter++;
// NOT USED     }
// NOT USED     assert(tot_dimension==counter);	//total dimensions should be equal to this number of variables denoted by counter
// NOT USED     /*
// NOT USED 
// NOT USED     //Reading and setting the Initial ID
// NOT USED     std::getline(in, line1);	//This read is for reading the Initial-Location-ID
// NOT USED     std::istringstream row2(line1);
// NOT USED     //cout<<"Transition Line is "<< line1<<endl;
// NOT USED     string init_label;
// NOT USED     unsigned int init_id;
// NOT USED     row2 >> init_label; //Reading First word of the line1 i.e., the word "Initial-mode"
// NOT USED     row2 >> init_id; //Reading the next word/value i.e., the Initial-Location-ID "1" (say)
// NOT USED     H->setInitialId(init_id);
// NOT USED     */
// NOT USED 
// NOT USED 	cout << "Hybrid Automata Object Created ..."<<endl;
// NOT USED //	if (log_set){
// NOT USED //		log_file << "Hybrid Automata Object Created ..."<<endl;
// NOT USED //	}
// NOT USED 
// NOT USED 	in.close();	//closing the file
// NOT USED }

// XXX  Largely duped
//This model-parser function will replace the above two parsing functions
void ha_model_parser(hybridAutomata::ptr &H, user_inputs::ptr &user
                     //, intermediateResult::ptr &intermediate  (not used)
                     )
{
	/*
	 * In this approach the learning algorithm creates transitions based on the connecting points and/or user-annotation 
between two modes.
	 * Thus, unlike the above two approaches i.e., one versus one and one versus rest where transitions depends on the number of modes is not the case here.
	 */
	//Has ODE parsing as common code

    string model_filename = user->getFilenameUnderOutputDirectory("learnHA_out.txt"); // XXX define a constant

	string eng_selected = user->getEngine();
	unsigned int modifyGuard = 1;	//modify by default for bbc
	if (eng_selected=="txt2slx") {
		model_filename = user->getModelFilename();
		modifyGuard = user->getGuard();
	} else if  (eng_selected=="learn-ha") {
		modifyGuard = user->getGuard();
	} else {	//This block is for engine = "bbc" and engine = "learn-ha-loop"
	}

	//******** modelfile now in the current directory **********
	/*
	 * Note:
	 * This modelfile has a specific format generated by the learning algorithm. The syntax and format is as follows:
	 * First line contains File-parameter-information (number-of-modes, number-of-dimension and number-of-transitions)
	 * ---------------------------------------------------------------------------
	 * The SECOND line has the initial starting location-ID as: Example:  Initial-mode 1
	 * ---------------------------------------------------------------------------
	 * Third line onwards contains the mode number-1
	 * Forth line contains the word "inv:"
	 * Fifth line contains the invariant expression
	 * Sixth line contains the word "ODE:"
	 * Seventh line the ODE for this mode for the first variable
	 * Eighth line the ODE for the 2nd variable (assume number-of-dimension=2)
	 * ---------------------------------------------------------------------------
	 * Ninth line contains the mode number-2
	 * Tenth line contains the word "inv:"
	 * Eleventh line contains the invariant expression
	 * Twelfth line contains the word "ODE:"
	 * Thirteenth line contains the ODE for this mode for the first variable
	 * Fourteenth line the ODE for the 2nd variable (assume number-of-dimension=2)
	 * ---------------------------------------------------------------------------

	 * Fifteenth line contain the Transition-Guard number-1
	 * Sixteenth line will contain Transition-Src-Dest	"src-id  =>  dest-id" Example: Transition-Src-Dest	1  =>  2
	 * Seventeenth line will contain the word "guard:"
	 * Eighteenth line will contain the polynomial-guard constraints
	 * Nineteenth line will contain the word "reset:"
	 * Twentieth line onward will contain the reset equation for each variable
	 * .... and so on.
	 *
	 * */

	std::ifstream in(model_filename.c_str()); //This is the file generated by running the Learning Algorithm
    if (!in) {
        std::cout << "Model file '" << model_filename << "' not found, verify if the Learning algorithm worked!!!" << std::endl;
        throw std::runtime_error("Model file " + model_filename + " not found");
	}

	unsigned int tot_modes, tot_dimension, tot_transitions;
    std::string line1;
    std::getline(in, line1); //Reading First Line: Each getline() function will read a line and moves the pointer to the beginning of the next line
    std::istringstream rowInitial(line1);
    //cout<<"Line is "<< line1<<endl;
    rowInitial >> tot_modes; //Reading First value the number-of-modes
    rowInitial >> tot_dimension; //Reading Second value the number-of-dimension
    rowInitial >> tot_transitions; //Reading Third value the number-of-transition-guard

    //cout << "tot_modes = "<<tot_modes<<"  tot_dim="<<tot_dimension <<"   tot_trans="<<tot_transitions <<endl;

    //Shifting the code for Initial Location-ID from the last line to the SECOND line.
    //Reading and setting the Initial ID
    std::getline(in, line1);	//This read is for reading the Initial-Location-ID
    std::istringstream row22(line1);
    //cout<<"Transition Line is "<< line1<<endl;
    string init_label;
    unsigned int init_id;
    row22 >> init_label; //Reading First word of the line1 i.e., the word "Initial-mode"
    row22 >> init_id; //Reading the next word/value i.e., the Initial-Location-ID "1" (say)
    H->setInitialId(init_id);

    //cout <<"Initial Location-ID=" << init_id <<endl;

    std::map<int, location::ptr> map_location_list1, map_location_list2; //mapping of the key loc_id to location::ptr
    //std::map<std::string, int> loc_name_map_id; //here name is used as a Key for ease of search
    //int loc_counter = 1; //loc-Id for key to map_loc_list
    //Reading All Mode's Invariant and ODE
    for (unsigned int i = 1; i <= tot_modes; i++) {	//Modes starts from 1
        location::ptr loc = location::ptr(new location());
        string label_modes;
        int mode_number;

        getline(in , line1);	//This read for reading the mode number
        std::istringstream row1(line1);
        //			cout<<"Line is "<< line1<<endl;
        row1 >> label_modes; //Reading First word of the line1 i.e., the word "mode"
        row1 >> mode_number; //Reading the next word/value i.e., the mode-number "1" (say)
        string mode_name = "mode"+ to_string(mode_number);
        loc->setLocId(mode_number);
        loc->setName(mode_name);


        // ******** Reading Mode Invariant **************
        //   simplified the invariant as a single string of expression. Better parsing and printing from learning-algo can be done later.
        getline(in , line1);	//This read for reading the word "inv:"
        std::istringstream row2(line1);
        //			std::cout<<"Line is "<< line1<<endl;
        std::string word_inv;
        row2 >> word_inv; //Reading the entire invariant expression
        //			std::cout<<"Word inv is "<< word_inv<<endl;

        getline(in , line1);	//This read for reading the invariant expression
        std::istringstream rowInv(line1);
        //			std::string mode_inv_str;
        //			rowInv >> mode_inv_str; //Reading the invariant expression
        std::list<std::string> list_inv;
        //list_inv.push_back(mode_inv_str);
        list_inv = string2list(line1);	//converting the entire inv expression into list of expression
        //list_inv.push_back(lst_inv);
        loc->setInvariant(list_inv);

        // ***********************************************


        // ******** Reading Mode ODE **************
        getline(in , line1);	//This read for reading the word "ODE:"
        std::istringstream row3(line1);
        std::string word_ode;
        row3 >> word_ode; //Reading the entire invariant expression
        //			std::cout<<"Word ODE is "<< word_ode<<endl;

        list<flow_equation> derivatives;

        for (unsigned int j = 0; j < tot_dimension; j++) {
            flow_equation ODEperVariable;
            string LHS, RHS;
            getline(in , line1);	//This read for reading the ODE for each dimension
            ODEperVariable.derivative = line1;
            std::istringstream lhsWord(line1);
            lhsWord >> ODEperVariable.varName; //Note it include the derivative symbol (')
            //				cout <<"ODE line " << line1 <<endl;
            size_t found = line1.find("=");
            if (found != string::npos) {
                //cout << "First occurrence is " << found << endl;
                //RHS = line1.substr (found+1);
                //ODEperVariable.RHSexpression = boost::trim_left(RHS);	//can think about constant dynamics later
                RHS = line1.substr (found+2); //Also left triming a white space
                ODEperVariable.RHSexpression = RHS;	//can think about constant dynamics later
                //cout << RHS << endl;
            } else {
                cout << "Invalid ODE equation found! " << endl;
                throw(new exception());
            }
            derivatives.push_back(ODEperVariable);
        }
        loc->setDerivatives(derivatives);	//First add all the modes without transition and later update the transition.
        map_location_list1[loc->getLocId()] = loc;
        //H->addLocation(loc);

        // ***********************************************
    }
    H->addMapped_Locations_List(map_location_list1);

    location::ptr my_location = location::ptr(new location());
    //my_location = map_location_list1[loc_id];	//accessing from the map data structure to create a new location with same ID and name
    //and fill up the remaining details and replace the hybrid_automata with this new detailed location


    // ******** Reading Transitions **************
    // each transition, has ID, srd: => dest: , guard:, guard expr, word reset:, reset expressions for each variable. Here there is no forward and backward trans

    double epsilon= user->getPrecisionGuardRange();

    //Reading All Transition-Guard:
    //std::vector<transition::ptr> forward(2);	//for mode m==3, we have 3 transitions, K = m * (m - 1)/2
    std::list<transition::ptr> all_transitions;

    for (unsigned int i = 1; i <= tot_transitions; i++) {	//Modes starts from 1

        string label, label_symbol, label_extra;

        transition::ptr trans = transition::ptr(new transition());
        string label_trans;
        unsigned int trans_number;

        getline(in , line1);	//This read for reading the transition number
        std::istringstream row1(line1);
        row1 >> label_trans; //Reading First word of the line1 i.e., the word "Transition-ID"
        row1 >> trans_number; //Reading the next word/value i.e., the Transition-number "1" (say)
        string trans_name = "trans"+ to_string(trans_number);
        trans->setTransId(trans_number);
        trans->setLabel(trans_name);

        unsigned int src, dest;
        std::getline(in, line1);	//This read for reading the word example: "Trans-Src-Dest 1 => 2"
        //cout <<"Trans Line="<<line1<<endl;
        std::istringstream row2(line1);
        row2 >> label_extra; //Reading First word of the line1 i.e., the word "Transition-Src-Dest"
        //cout<<"Transition Src-Dest Label is "<< label<<endl;
        row2 >> src; //Reading the next word/value i.e., the Src-mode-id "1" (say)
        //cout<<"Src = "<<src<<endl;
        row2 >> label_symbol; //Reading First word of the line1 i.e., the word " => "
        //cout<<"Transition Arrow Label is "<< label<<endl;
        row2 >> dest; //Reading the next word/value i.e., the Dest-mode-id "2".
        //cout<<"Dest-1 = "<<dest<<endl;

        trans->setSourceLocationId(src);
        trans->setDestinationLocationId(dest);
        //cout<<"Transition Src "<< trans->getSourceLocationId()<<endl;
        //cout<<"Transition Dest "<< trans->getDestinationLocationId()<<endl;


        // ******** Reading Transition-guard **************

        std::getline(in, line1);	//This read for reading the word "guard:"
        //cout <<"Trans Line="<<line1<<endl;
        std::istringstream row3(line1);
        row3 >> label_extra;
        //			cout<<"word guard = " << label_extra <<endl;

        std::list<std::string> guard;
        std::getline(in, line1);	//This read for reading the polynomial-guard constraints
        guard.push_back(line1);
        //cout<<"Transition Guard line1 is "<< line1<<endl;
        trans->setGuard(guard);

        // ** Working for the Modified Guard to support inequality **
        std::list<std::string> guard_modified;

        if (modifyGuard == 0) { //user decided not to modify guard
            //trans->setGuardModified(guard);

            //cout <<"guard = " << (*trans->getGuardModified().begin()) <<endl;
            //check if user input "=" then modify to "==" to support Matlab's simulink syntax. This is done only when user decide not to modify guard.
            // Since the correct input symbol in the guard equation is "=" in the model file. But in matlab simulink the correct symbol is "==".
            std::list<std::string> correct_guard;
            correct_guard = correctGuard(line1);
            trans->setGuardModified(correct_guard);
            //cout <<"guard = " << (*trans->getGuardModified().begin()) <<endl;

        } else {	// modify gurad to inequality

            //guard_modified = modify_guard_asRange(guard, epsilon);		//converting to range as inequality. Working with epsilon ERROR

            //Trying to modify guard into halfspace instead of inequality-with-range from hyperplane.
            //Practical observation showed data having src(+1) => dest(-1); gives guard-condition <= 0
            guard_modified = modify_guard_asHalfspace(guard, epsilon);		//converting " = 0" to "<= epsilon". Decision based on SVM's output observation

            trans->setGuardModified(guard_modified);
        }
        // ***********************************************

        // ******** Reading Transition-Reset **************

        std::getline(in, line1);	//This read for reading the word "Reset:"
        //cout <<"Trans Line="<<line1<<endl;
        std::istringstream row4(line1);
        row4 >> label_extra;
        //			cout<<"word reset = " << label_extra <<endl;

        std::list<reset_equation> list_reset;

        for (unsigned int j = 0; j < tot_dimension; j++) {
            reset_equation reset_per_variable;
            string LHS, RHS;
            getline(in , line1);	//This read for reading the reset for each dimension
            reset_per_variable.reset_expression = line1;
            std::istringstream lhsWord(line1);
            lhsWord >> reset_per_variable.varName; //Note it include the prime symbol (')

            size_t found = line1.find("=");
            if (found != string::npos) {
                RHS = line1.substr (found+2); //Also left triming a white space
                reset_per_variable.RHSexpression = RHS;	//can think about constant dynamics later
                //cout << RHS << endl;
            } else {
                cout << "Invalid Reset equation found! " << endl;
                throw(new exception());
            }
            list_reset.push_back(reset_per_variable);
        }
        trans->setAssignment(list_reset);

        // ***********************************************


        all_transitions.push_back(trans);//collecting all the transitions together
    } //End of reading all transitions


    if (tot_modes >= 1 && all_transitions.size() >= 1) {

        std::map<int, location::ptr> list_locations;
        list_locations = H->getLocation_List();

        //Iterate through all the modes get the mode-id and create list-of-Transitions and add as outGoingTransitions
        for (std::map<int, location::ptr>::iterator i= list_locations.begin(); i != list_locations.end(); i++) {
            location::ptr loc = (*i).second;	//since our location starts from 0
            //cout<<"Location Name: "<<loc->getName() <<"  ID: "<< loc->getLocId()<<endl;
            unsigned int src = loc->getLocId();
            list<transition::ptr> trans = getAllTrans(src, all_transitions);

            my_location = map_location_list1[src];	//i here is the mode-id
            my_location->setOutGoingTransitions(trans);	//the location is now updated with out-going-transition
            map_location_list2[src] = my_location;

        }
        //cout<<"back_trans_ created="<<endl;
    }

    if (tot_modes >= 1 && all_transitions.size() >= 1) { //Modification of Transition is required only for modes > 1
        //cout<<"Total number of Locations (2) ="<<H->getTotalLocations() <<endl;
        H->addMapped_Locations_List(map_location_list2);	//This line is important to update the transitions
    }
    // ***********************************************
	//cout << "Hybrid Automata Object Created ..."<<endl;

	in.close();	//closing the file

}

// Replaces the expression containing "=" into "==", also returns as a list of expression
std::list<std::string> correctGuard(std::string line1){

	//string line1="x0 >= 0.344648094532294";
	//string line1="x0 >= 0.344648094532294 && x0 = 60.7002 && x1 >= 905.32532 && x1 = 1093.212";
	typedef boost::tokenizer<boost::char_separator<char> > tokenizer;
	boost::char_separator<char> sep("&");
	tokenizer tokens(line1, sep);
	list<string> each_guard;
	for (tokenizer::iterator tok_iter = tokens.begin();	tok_iter != tokens.end(); ++tok_iter) {
		string ss = (std::string)(*tok_iter);
		boost::trim(ss);
		each_guard.push_back(ss);
	}


	for (list<string>::iterator it=each_guard.begin(); it != each_guard.end(); it++){
		std::string & the_guard(*it);	//reference
		//cout <<"the_guard:" << the_guard <<endl;
		boost::char_separator<char> sep1(" ");
		tokenizer tokens1(the_guard, sep1);
		unsigned int found=0;
		for (tokenizer::iterator tok_iter1 = tokens1.begin(); tok_iter1 != tokens1.end(); ++tok_iter1) {
			//cout << (*tok_iter1) << endl;
			if ((*tok_iter1) == "="){
				//cout <<"found = sign" <<endl;
				found=1;
			}
		}
		if (found) {
			unsigned int pos = the_guard.find("=");
			string  replacestr1="==";
			//cout <<"token before: " <<(*it) << "  the_guard:" << the_guard << endl;
			the_guard.replace(pos, 1, replacestr1);
			//cout <<"token after: " <<(*it) << "  the_guard:" << the_guard << endl;
		}
	}

	return each_guard;
}


//Take a list<string> of guard and returns list<string> of modified guard and argument a double epsilon value
//Assuming the list of string has only a single string and not a list. TODO: if the guard is not a polynomial equation
std::list<std::string> modify_guard_asRange(std::list<std::string> guard, double epsilon) {
	std::list<std::string> changed_guard;
	///Assuming that the guard is of the form ax+by = 0   Note: THE blank space before and after the zero on the RHS.

	for (std::list<std::string>::iterator gd = guard.begin(); gd != guard.end(); gd++) {
		string str = (*gd);
		std::string search_key (" = ");
		unsigned int guard_length = str.size();
		std::size_t found = str.rfind(&search_key[0], guard_length, 3);	//searching from reverse so position is guard_length and match 3 characters from the search_key in the str

		if (found != std::string::npos) {

		    string str1=str, str2=str, replacestr1=" >= "+to_string(-1 * epsilon)+" + ", replacestr2=" <= "+to_string(epsilon)+" + ";

			str1.replace(found, search_key.length(), replacestr1);
			changed_guard.push_back(str1);

			str2.replace(found, search_key.length(), replacestr2);
			changed_guard.push_back(str2);
		} else { // operator " = " not found so just keep the guard as it is
			changed_guard.push_back(str);
		}

		/*unsigned int pos = str.find("=");
		string str1=str, str2=str, replacestr1=">= "+to_string(-1 * epsilon)+" + ", replacestr2="<= "+to_string(epsilon)+" + ";
		str1.replace(pos, 1, replacestr1);
		changed_guard.push_back(str1);

		str2.replace(pos, 1, replacestr2);
		changed_guard.push_back(str2);*/
	}



	return changed_guard;
}

//Takes a string of guard with "=" symbol and convert it into "<=". This decision is made due to the SVM's output observation
std::list<std::string> modify_guard_asHalfspace(std::list<std::string> guard, double epsilon) {
	std::list<std::string> changed_guard;
	///Assuming that the guard is of the form ax+by = 0   Note: THE blank space before and after the zero on the RHS.

	for (std::list<std::string>::iterator gd = guard.begin(); gd != guard.end(); gd++) {
		string str = (*gd);
		std::string search_key (" = ");
		unsigned int guard_length = str.size();
		std::size_t found = str.rfind(&search_key[0], guard_length, 3);	//searching from reverse so position is guard_length and match 3 characters from the search_key in the str

		if (found != std::string::npos) {

			string str2=str, replacestr2=" <= "+to_string(epsilon)+" + ";
			str2.replace(found, search_key.length(), replacestr2);
			changed_guard.push_back(str2);
		} else { // operator " = " not found so just keep the guard as it is
			changed_guard.push_back(str);
		}
	}

	return changed_guard;
}

//Take a list<string> of guard and returns list<string> of modified guard as epsilon-range value Also ANDing with randomization for non-deterministic transitions
std::list<std::string> modify_guard_forNonDeterminism(std::list<std::string> guard, double epsilon, unsigned int sign) {
	std::list<std::string> changed_guard;
	///Assuming that the guard is of the form ax+by = 0   Note: RHS is 0

	std::list<std::string>::iterator gd = guard.begin();
	string str = (*gd);
	unsigned int pos = str.find("=");
	/*if (less_or_greater == 1)
		str.replace(pos, 1, "<=");
	else if (less_or_greater == 2)
		str.replace(pos, 1, ">=");*/

	string str1=str, str2=str, replacestr1=">= "+to_string(-1 * epsilon)+" + ", replacestr2="<= "+to_string(epsilon)+" + ";
	string str3="";

	str1.replace(pos, 1, replacestr1);
	changed_guard.push_back(str1);

	str2.replace(pos, 1, replacestr2);
	changed_guard.push_back(str2);
	if (sign == 1) //1 for >= 0   and   2 for < 0
		str3 = " myRandomOut() >= 0";
	else
		str3 = " myRandomOut() < 0";
	changed_guard.push_back(str3);

	return changed_guard;
}




//Take a list<string> of guard and returns list<string> of modified guard and argument less_than_equal=1 and greater_than_equal=2
//Assuming the list of string has only a single string and not a list. TODO: if the guard is not a polynomial equation
std::list<std::string> modify_guard(std::list<std::string> gurad, unsigned int less_or_greater) {
	std::list<std::string> changed_guard;

	std::list<std::string>::iterator gd = gurad.begin();
	string str = (*gd);
	unsigned int pos = str.find("=");
	if (less_or_greater == 1)
		str.replace(pos, 1, "<=");
	else if (less_or_greater == 2)
		str.replace(pos, 1, ">=");

	changed_guard.push_back(str);

	return changed_guard;
}


list<transition::ptr> getAllTrans(unsigned int src, std::vector<transition::ptr> forward, std::vector<transition::ptr> backward) {
	list<transition::ptr> trans;
	for (unsigned int i=0; i<forward.size(); i++) {
		if (src == forward[i]->getSourceLocationId()) {
			trans.push_back(forward[i]);
		}
	}
	for (unsigned int i=0; i<backward.size(); i++) {
		if (src==backward[i]->getSourceLocationId()){
			trans.push_back(backward[i]);
		}
	}
	return trans;
}

list<transition::ptr> getAllTrans(unsigned int src, list<transition::ptr>& all_trans) {
	list<transition::ptr> sublist_trans;
	transition::ptr this_trans;

	for (list<transition::ptr>::iterator it=all_trans.begin(); it != all_trans.end(); it++) {
		if (src == (*it)->getSourceLocationId()) {
			this_trans = (*it);
			sublist_trans.push_back(this_trans);
		}
	}

	return sublist_trans;
}


//Function for Debugging the output of HA
void verifyHA_output(hybridAutomata::ptr &H) {


	cout << "*********Verify HA Output*********"<<endl;
	cout << "Total number of Locations = "<< H->getTotalLocations()<<endl;


	H->print_var_mapping();

	cout<< "Initial Location ID: "<< H->getInitialId() <<endl;

	std::map<int, location::ptr> list_locations;
	list_locations = H->getLocation_List();

	for (std::map<int, location::ptr>::iterator i= list_locations.begin(); i != list_locations.end(); i++) {
		location::ptr loc = (*i).second;	//since our location starts from 0
		cout <<"\n======****** Mode Details ******======"<<endl;
		cout << "Location Name: "<<loc->getName() <<"  ID: "<< loc->getLocId()<<endl;
		std::list<std::string> inv_test = loc->getInvariant();
		for (std::list<std::string>::iterator mod_inv = inv_test.begin(); mod_inv != inv_test.end(); mod_inv++){
			std::cout << "Invariant: " << (*mod_inv) << std::endl;
		}

		list<flow_equation> derivatives = loc->getDerivatives();

		for (list<flow_equation>::iterator it_flow = derivatives.begin(); it_flow != derivatives.end(); it_flow++) {
			std::cout << "Flow: "<<(*it_flow).derivative<< std::endl;
			//cout<<"Flow:varName "<<(*it_flow).varName<<endl;
			//cout<<"Flow:RHS "<<(*it_flow).RHSexpression<<endl;
		}

		list<transition::ptr> trans = loc->getOutGoingTransitions();
		std::cout <<"====== Outgoing transition ======"<< std::endl;
		for (list<transition::ptr>::iterator it_trans = trans.begin(); it_trans != trans.end(); it_trans++) {
			std::cout <<"Transition ID: "<< (*it_trans)->getTransId()<< std::endl;
			std::cout <<"Transition Label: "<< (*it_trans)->getLabel()<< std::endl;
			std::cout <<"Transition Source-ID and Destination-ID:  "<< (*it_trans)->getSourceLocationId() << "  --->   "<< (*it_trans)->getDestinationLocationId()<< std::endl;


			std::list<std::string> guard = (*it_trans)->getGuard();
			list<std::string>::iterator it_guard = guard.begin();
			std::cout<< "Transition-Guard: "<< (*it_guard)<<endl;

			std::list<std::string> guard_modified = (*it_trans)->getGuardModified();
			string guard_changed = (*guard_modified.begin());
			std::cout<< "Transition-Modified Guard: " << std::endl;
			for (std::list<std::string>::iterator mod_guard=guard_modified.begin(); mod_guard != guard_modified.end(); mod_guard++){
				std::cout << (*mod_guard) << std::endl;
			}

			std::cout<< "Transition-Reset: "<< std::endl;
			list<reset_equation> reset_eqs = (*it_trans)->getAssignment();
			for (list<reset_equation>::iterator it_reset = reset_eqs.begin(); it_reset != reset_eqs.end(); it_reset++) {
				std::cout << "Reset: " << (*it_reset).reset_expression << std::endl;
				//cout<<"Reset: varName "<<(*it_reset).varName << endl;
				//cout<<"Reset: RHS "<<(*it_reset).RHSexpression << endl;
			}

		}//End of the Transition
	} //End of the Location

}


void modelConstruction(hybridAutomata::ptr &H, user_inputs::ptr &user, intermediateResult::ptr &intermediate, summary::ptr &report) {
	//*****************************************
    // file_with_path = $outdir/$outdir.drh
	string file_with_path = user->getFilenameUnderOutputDirectory("model.drh");
	//*****************************************

	boost::timer::cpu_timer inputModelCreation;
	inputModelCreation.start();
	//************************************
	modelConstructor::ptr dreachModel = modelConstructor::ptr(new modelConstructor());
	ofstream modelfile;
	modelfile.open(file_with_path);
	if (!modelfile.is_open()) {
		std::cout << "Error opening file: " << file_with_path;
        throw std::runtime_error("Error opening file: " + file_with_path);
    }
    
    std::cout << "\nFile " << file_with_path << " created for Model-Checking using dReach Tool ...\n";
    modelfile << "//Constructing dReach Model-File from tool BBC4CPS";
    modelfile << "\n";
    dreachModel->printModelFile(H, modelfile, user);
	modelfile.close();
	//************************************
	inputModelCreation.stop();
	double wall_clock_modelParser;
	wall_clock_modelParser = inputModelCreation.elapsed().wall / 1000000; //convert nanoseconds to milliseconds
	double running_time = wall_clock_modelParser / (double) 1000;	//convert milliseconds to seconds
	//std::cout << "Model Parsing into Hybrid Automaton: Running Time (in Seconds) = " << running_time<<endl;
	report->setRuntimeInputModelConstruction(running_time);

	std::cout << "\n dReach input-model file created ...\n";
}

/*
 * separates the string into list of string, where separation is done based on "& "
 */
std::list<std::string> string2list(std::string input_str) {
	std::list<std::string> lst_string;
	//input_str="x0>=0.344648094532294 & x0<=60.7002246998343 & x1>=905.325240216932 & x1<=1093.21291463544";
	typedef boost::tokenizer<boost::char_separator<char> > tokenizer;
		boost::char_separator<char> sep("&");
		tokenizer tokens(input_str, sep);
		for (tokenizer::iterator tok_iter = tokens.begin();
				tok_iter != tokens.end(); ++tok_iter) {
			//std::cout << (*tok_iter) << endl;
			string ss = (std::string) (*tok_iter);
			boost::trim(ss);
			//std::cout << ss << endl;
			lst_string.push_back(ss);
		}
	return lst_string;
}




void readlastWord(){

	const char* runResultfile = "sys_generated_tempfile.txt";
	std::ifstream in(runResultfile); //This is the file generated from dReach output: For s sample see output file "modelChecker/sample_output_file.txt"
	std::string dReach_result;

	//Read all the lines the last word of the last line contain word SAT or unsat
	if (in) {
		while (!in.eof()) {
			std::string line1;
			std::getline(in, line1); //Reading First Line for total intermediate, input and output variables
			std::istringstream row1(line1);
			for ( ;row1 >> dReach_result; ) {
			 //Reading upto the last word
				std::cout <<"dReach-result = "<<dReach_result<<std::endl;
			}
		}
		std::cout <<"The last word is = "<<dReach_result<<std::endl;
	}

}
