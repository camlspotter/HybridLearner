/*
 * simulation.cpp
 *
 *  Created on: 05-Oct-2021
 *      Author: amit
 */


#include "../utilities/matlab.h"

#include <vector>
#include "../commandLineParser/user_inputs.h"
#include "../utilities/polytope/polytope.h"
//#include "engine.h"
#include "../utilities/hyperbox/hyperbox.h"
#include "../utilities/math/randomGenerator.h"
#include "../utilities/intermediateResult.h"
#include "simulation_trace_testing.h"
#include "../utilities/myRandomNumberGenerator.h"
#include "../utilities/system.h"


#include "../benchmark/circle/runCircle.h"
#include "../benchmark/oscillator/runOscillator.h"
#include "../benchmark/shared_gas_burner/runSharedGasBurner.h"
#include "../benchmark/nav_inst1/runNav_inst1.h"
#include "../benchmark/AFC/runAFC.h"
#include "../benchmark/AT/runAT.h"
#include "../benchmark/bball_with_input/runBBall.h"

using namespace std;
using namespace matlab::engine;

bool safetyCheck(user_inputs::ptr &user, double &violation_TimeHorizon);

bool variableBoundCheck(string varName, double varValue, std::list<struct variable_bounds> list_VarBounds);

const std::string getSimulationOutputFileName(unsigned int model, const std::string &toolRootPath);


/*
 * Generate random simulation points from a Polytope (Note: polytope should obey the
 * formation rule of a hyberbox. Each dimension should have both the upper and lower bounds. Ax <= b where b is the bound.
 */

std::list< std::vector<double> > getInternalPoints(polytope::ptr &poly, unsigned int n, myRandomNumberGenerator::ptr &randomGenObj);


std::list<std::list<struct control_points>> getInternalControlPoints(polytope::ptr &poly, unsigned int n_simulations, list<struct control_points> list_var_cps, myRandomNumberGenerator::ptr &randomGenObj);

void fixed_step_signal(double th, std::vector<double> cps, std::vector<double> &time_vector, std::vector<double> &data_vector);


void linear_signal(double th, std::vector<double> cps, std::vector<double> &time_vector, std::vector<double> &data_vector);

void spline_signal(std::unique_ptr<MATLABEngine> &ep, double th, std::vector<double> cps, std::vector<double> &time_vector, std::vector<double> &data_vector);


void sine_wave_signal(double timeHorizon, double amplitude, double zero_offset, std::vector<double> &time_vector, std::vector<double> &data_vector);


using namespace std;
using namespace matlab::engine;

bool safetyCheck(user_inputs::ptr &user, double &violation_TimeHorizon) {

//	extern  unsigned int log_set;
//	std::ofstream log_file("bbc4cps_log_file.txt",  std::ios_base::binary | std::ios_base::app);

	unsigned int dim = user->getSysDimension();

	const char* resultfile;
    // XXX DUPE!
	if (user->getModel() == 1) {
		resultfile = "../src/benchmark/circle/result.txt";
	} else if (user->getModel() == 2) {
		resultfile = "../src/benchmark/oscillator/result.txt";
	} else if (user->getModel() == 3){
		resultfile = "../src/benchmark/shared_gas_burner/result.txt";
	} else if (user->getModel() == 4){
		resultfile = "../src/benchmark/nav_inst1/result.txt";
	} else if (user->getModel() == 5){
		resultfile = "../src/benchmark/AFC/result.txt";
	} else if (user->getModel() == 6){
		resultfile = "../src/benchmark/AT/result.txt";
	} else if (user->getModel() == 7){
		resultfile = "../src/benchmark/bball_with_input/result.txt";
	}

	//std::cout << "\nUnsafe Polytope going to create polytope: \n";
	polytope::ptr unsafe_poly;
	double gt_lower=0.0, gt_upper=user->getTimeHorizon();	//default 0 to time-horizon
	string_to_polytope_withTimeBound(user->getGoalString(), unsafe_poly, gt_lower, gt_upper);	//Returns a polytope from string along with lower and upper time bound
	//Taking care of time-constraints (gt>=10 & gt<=time-horizon)
	//cout <<"Time lower = "<< gt_lower << "  time upper=" <<gt_upper <<endl;

	std::ifstream in(resultfile);	//This is the file generated by running the simulation. So it always maintains the order of the outputs (time, variables)

	bool found=false;
	if (in) {
		std::string line1;
		double time_t=0, distance=0.0;
		std::vector<double> variable_value(dim);
		while (std::getline(in, line1)) {
			std::istringstream word(line1);
			word >> time_t;	//reads the first number which is time value

			for (unsigned int i=0; i < dim; i++) {
				word >> variable_value[i]; //Reading rest of the columns consisting of variables value.
			}
			//Step 2) Now test/check if this generated data actually Falsify the safety property.
			/*std::cout << "\nUnsafe Polytope: \n";
			std::cout << unsafe_poly->getCoeffMatrix() << "\n";
			for (unsigned int i=0; i < unsafe_poly->getColumnVector().size(); i++){
				std::cout <<unsafe_poly->getColumnVector()[i] << std::endl;
			}*/

			//Todo: check if every system variable_value[i] is within the supplied input bounds/variable's invariant
			std::list<struct variable_bounds> list_VarBounds = user->getListVariableBounds(); //this list contains the MinMax bounds
			string varName = "";
			bool isValidBound = false;
			for (unsigned int i=0; i < dim; i++) {
				//variable_value[i]; //Reading variable's value.
				varName  = "x";
				varName.append(to_string(i));
				//std::cout <<"varName = " << varName << " value = " << variable_value[i] << "\t";
				isValidBound = variableBoundCheck(varName, variable_value[i], list_VarBounds);
				if (isValidBound == false) {
					found = false;
					break;
				}
			}
			//std::cout << std::endl;
			if (isValidBound == false) { //This is required to come out of the while loop
				//found = false; //already done above
				break;  //this will skip checking the below safety property
			}

			if (time_t >= gt_lower && time_t <= gt_upper) {
				distance = unsafe_poly->point_distance(variable_value); //returns 0 if point is inside the polytope
//				cout << "distance = "<< distance<<endl;
				/*if (log_set){
					 log_file << "(";
					for (unsigned int i=0; i < dim; i++) {
						log_file << variable_value[i]; //Reading rest of the columns consisting of variables value.
						if (i != (dim - 1)){
							log_file << " , ";
						}
					}
					log_file << ")  ";
					log_file << " distance = "<< distance<<endl;
				}*/
				if (distance == 0) {
					found = true;
					//Also return the Time-Bound when the violation is Found
					violation_TimeHorizon = time_t;
					break;
				}
			}
		} //end-while

		if (found) {
			cout << "Found a Valid Counter-example!!!"<<endl;
		} else {
			cout << "NO Valid Counter-example Found!!!"<<endl;
		}
	} //end of file reading

	in.close();	//closing the file

	return found;
}

/*
 * Returns True for Valid bound.
 * Returns True if the varName is within the supplied bounds, otherwise returns False.
 */
bool variableBoundCheck(string varName, double varValue, std::list<struct variable_bounds> list_VarBounds) {
	bool flag=false, varNotFound = true;
	double epsilon = 1e-7; // 0.0000001;
	double diffValueLow = 0.0, diffValueHigh=0.0;
	for (std::list<struct variable_bounds>::iterator it = list_VarBounds.begin(); it != list_VarBounds.end(); it++) {
		if ((*it).variable_name == varName) { //for this variable
			//cout <<"varValue=" << varValue <<"   Min value="<< (*it).min_value << " and Max value="<<(*it).max_value << endl;
			//double low = (*it).min_value - varValue,  high = varValue - (*it).max_value;
			double low = (*it).min_value,  high = (*it).max_value;
			diffValueLow = abs(low - varValue);
			diffValueHigh = abs(high - varValue);
			//if (varValue > low || cond2) && (cond3 || cond4) {
			if (((varValue > low) || (diffValueLow < epsilon)) && ((varValue < high) || (diffValueHigh < epsilon))) {
//			if ((varValue >= (*it).min_value) && (varValue <= (*it).max_value)) { //checking the bounds
			//if ((varValue >= low) && (varValue <= high)) { //checking the bounds  ToDo: equal value is not comparing correctly for Double data type
				flag = true;
			} else {
				std::cout <<"Input Bound: violated by the Variable " << varName <<" Valid bound=[" << (*it).min_value << ", " << (*it).max_value << "] but value=" << varValue << endl;
				if (varValue == low) { //900==900 this did not return TRUE
					cout <<"Here varValue("<<varValue<<") >= low("<<low<<")" <<endl;
				}
				std::cout <<"Input Bound: violated by the Variable " << varName <<" Valid bound=[" << low << ", " << high << "] but value=" << varValue << endl;
				//cout <<"Amit this is comparison problem with 900 and varValue=" << varValue << " low=" << low << " and high="<<high <<endl;
				flag = false;
			}
			varNotFound = false;
			break; //found the matching variable
		}
	}
	if (varNotFound) { //this will never get executed since all variable has some bounds or max-value as the bounds
		std::cout <<"Error: Variable bounds not assigned!" <<endl;
		flag = true; //so considering Universal bounds
	}
	return flag;
}


std::list< std::vector<double> > getInternalPoints(polytope::ptr &poly, unsigned int n, myRandomNumberGenerator::ptr &randomGenObj) {
	std::list< std::vector<double> > res;
	/*
	 * Steps:
	 * 1) First assert if poly obeys the rule (check rows should be twice as dimension AND the pattern -1 and +1 should exists with rest 0)
	 * 2) For each dimensions with extracted bounds (lower,upper) generate n randomly uniform_real_distrubution values
	 * 3) Use these values to create points for simulation
	 *
	 * todo: Note this loop implementation may not work if the order of Constraints creation do not follow increasing order of the Dimension.
	 * Need to modify it later
	 *
	 */
	math::matrix<double> A = poly->getCoeffMatrix();
	std::vector<double> bounds = poly->getColumnVector();

    std::cout << "poly" << endl;
    poly->printPoly();

	unsigned int rows, cols, dim;
	rows = A.size1();
	cols = A.size2();
	dim = cols;
	assert(rows == 2 * cols);	//For hyperbox number of constraints should be bounded (lower and upper)

	hyperbox::ptr hyperbox_poly = hyperbox::ptr(new hyperbox(dim));

	//For each dimension of the hyperbox generating a list of bounded values, which can be used as points
	std::vector<std::vector<double> > hyperbox_dimension_points(dim);
	for (unsigned int i=0;i<dim;i++){
		hyperbox_dimension_points[i].resize(n);	//each dimensions will have n values for generating points
	}

	unsigned int i=0, j=0;
	double rowFirst, rowSecond, l_bound, u_bound;
	//Creating a hyperbox from initial input_poly
	while (j < cols) {	//reading the none-zero dimensions
		if (A(i,j) != 0) {	//j is the dimension we are working on
			rowFirst = j * 2;	//
			rowSecond = j * 2 + 1;

			// found the dimension with non-zero value, which should be 1
			//cout  << "  " << A(rowFirst,j) << " and Next is  " << A(rowSecond,j);
			//One of these will be -1 and the other 1. Find and accordingly create lower and upper bounds on the dimension
			if (A(rowFirst, j) < A(rowSecond, j)) {
				l_bound = -1 * bounds[rowFirst];
				u_bound = bounds[rowSecond];
			} else {
				l_bound = -1 * bounds[rowSecond];
				u_bound = bounds[rowFirst];
			}
			hyperbox_poly->setDimensionBounds(j, l_bound, u_bound);

//			hyperbox_dimension_points[j] = getRandom(l_bound, u_bound, n);	//Pseudo random which will be repeated on every execution
			//hyperbox_dimension_points[j] = getPureRandom(l_bound, u_bound, n);	//purely random which will NOT be repeated on every execution
			hyperbox_dimension_points[j] = randomGenObj->getRandomNumbers(l_bound, u_bound, n);


		}
		i +=2;
		j++;
	}

	std::vector<double> point(dim); //A single point

	for (unsigned int i=0; i< n;i++) {
		for (unsigned int j=0; j<dim; j++){
			point[j] = hyperbox_dimension_points[j][i];
		}
		res.push_back(point);
	}

	return res;
}

/*
 * nos_simulations: the total number of simulation points
 * list_var_cps: number of control-points for each variable
 * polytope::ptr &poly: is the initial input polytope which has linear-constraints having bounds on the variables
 * Outputs: is a purely random control-points for each variable for generating input-signals for each simulations
 * By using a seed
 */
// list_var_cps is the specification of variables:
//   { var_index : int; var_name : string; var_type : string; numberOf_cp : uint }
//   Note that vector<double> cps is NOT used here!
//
// It generates `nos_simulations` of simulation points.
// Each simulation point is a list of `control_points`.
// Each `control_points` has `numberOf_cp` `doubles`.
std::list<std::list<struct control_points> > getInternalControlPoints(polytope::ptr &poly,
                                                                      unsigned int nos_simulations,
                                                                      list<struct control_points> list_var_cps,
                                                                      myRandomNumberGenerator::ptr &randomGenObj)
{
	std::list<std::list<struct control_points>> res_data;
	std::list< std::vector<double> > res;

	math::matrix<double> A = poly->getCoeffMatrix();
	std::vector<double> bounds = poly->getColumnVector();

	unsigned int rows, cols, dim;
	rows = A.size1();
	cols = A.size2();
	dim = cols;

    //	cout <<"rows =" <<rows << "   and cols =" << cols << endl;
	assert(rows == 2 * cols);	//For hyperbox number of constraints should be bounded (lower and upper)

	//For each dimension of the hyperbox generating a list of bounded values, which can be used as points
	std::vector<std::vector<double> > hyperbox_dimension_points(dim);
	unsigned int index=0;
	for (std::list<struct control_points>::iterator it = list_var_cps.begin();it != list_var_cps.end();it++){ //each-variable will have N-control-points
		int numberOf_cp = (*it).numberOf_cp;
		//cout << "var_name:" << (*it).var_name << endl;
		//cout << "cps-size:" << (*it).numberOf_cp << endl;
		hyperbox_dimension_points[index].resize(numberOf_cp);	//each dimensions will have n values for generating points
		index++;
	}
	//cout << "nos_simulations:" << nos_simulations <<endl;
	//cout << "dim:" << dim <<endl;
	//cout << "A of poly is " << A <<endl;

	for (unsigned int simu_id=0; simu_id < nos_simulations; simu_id++) { //repeated for nos_simulations times

		hyperbox::ptr hyperbox_poly = hyperbox::ptr(new hyperbox(dim));
		unsigned int i=0, j=0;
		double l_bound, u_bound;
		unsigned int rowFirst, rowSecond;
		//Creating a hyperbox from initial input_poly
		while (j < cols) {	//reading the none-zero dimensions
			//std::cout << "rows = " << rows << "  cols = " << cols << endl;
			if (A(i,j) != 0) {	//j is the dimension we are working on
				rowFirst = j * 2;	//
				rowSecond = j * 2 + 1;
				// found the dimension with non-zero value, which should be 1
				//std::cout  << "  " << A(rowFirst,j) << " and Next is  " << A(rowSecond,j);
				//One of these will be -1 and the other 1. Find and accordingly create lower and upper bounds on the dimension
				if (A(rowFirst, j) < A(rowSecond, j)) {
					l_bound = -1 * bounds[rowFirst];
					u_bound = bounds[rowSecond];
				} else {
					l_bound = -1 * bounds[rowSecond];
					u_bound = bounds[rowFirst];
				}
				hyperbox_poly->setDimensionBounds(j, l_bound, u_bound);

                // hyperbox_dimension_points[j].size() random numbers in [l_bound,u_bound] 
				hyperbox_dimension_points[j] = randomGenObj->getRandomNumbers(l_bound, u_bound, hyperbox_dimension_points[j].size());
			}
			i +=2;
			j++;
		}
		index=0;
		std::list<struct control_points> list_cp;
		for (std::list<struct control_points>::iterator it = list_var_cps.begin();it != list_var_cps.end();it++){ //each-variable will have N-control-points
			struct control_points cp_data;

			cp_data.numberOf_cp = (*it).numberOf_cp;
			cp_data.var_name = (*it).var_name;
			cp_data.var_type = (*it).var_type;
			cp_data.var_index = (*it).var_index;
			cp_data.cps = hyperbox_dimension_points[index];

			list_cp.push_back(cp_data);
			index++;
		}
		res_data.push_back(list_cp);
	}


	return res_data;
}

// fixed_step_signal(timeHorizon, control_points, time_vector, data_vector)
//   [( [t_i, t_{i+1}), p_i )]_{i in [0..n-1]} 
//   or [ (t_i, p_i), (t_{i+1} - epsilon, p_i) ]_{i in [0..n-1]} 
//   where
//      t_i = timeHorizon * i / n   (not / (n+1) somehow)
void fixed_step_signal(double th, std::vector<double> cps, std::vector<double> &time_vector, std::vector<double> &data_vector) {
    // **** This code is for ONE variable *********
	int nos_cp= cps.size();
	double hold_time_dur = th/nos_cp, small_value=1e-7;	//0.0000001; //1e-5;
	std::vector<double> timeVector(nos_cp * 2);
	std::vector<double> dataVector(nos_cp * 2);

    cout << "fixed_step_signal timehorizon:" << th << endl;
    cout << "  cps: "; 
    for (auto it = cps.begin(); it != cps.end(); it++){
        cout << *it << " ";
    }
    cout << endl;

	double sum_holdtime=0, start_val=0;
	unsigned int index=0;
	for(int i=0; i< nos_cp; i++) {
		if (i==0) {
			start_val = 0;
		} else {
			start_val = sum_holdtime + small_value;
		}
		timeVector[index] = start_val;
		dataVector[index] = cps[i];
		index++;

		sum_holdtime += hold_time_dur;
		timeVector[index] = sum_holdtime;
		dataVector[index] = cps[i];
		index++;

	}
}

//Function to generate constant-piecewise-linear signal, where the hold-time is fixed/uniform for each control-points
//   [( t_i, p_i )]_{i in [0..n-1]} 
//   where
//      t_i = timeHorizon * i / (n-1)
void linear_signal(double th, std::vector<double> cps, std::vector<double> &time_vector, std::vector<double> &data_vector) {

	// **** This code is only for a single variable *********
	unsigned int nos_cp= cps.size();

    if (nos_cp <= 1) {
		std::cout << "\nTerminating BBC4CPS, caused due to error in command-line inputs.\n" ;
		std::cout << "Invalid number-of-control-points. Minimum number of fixed-linear control-points for a variable is 2.\n";
		exit(1);
	}

	double hold_time_dur = th / (nos_cp-1);

	//data [cp1 cp2  cp3]
	//timeVector[0 hold_time_dur*1   hold_time_dur*2]
	std::vector<double> timeVector(nos_cp);
	std::vector<double> dataVector(nos_cp);

	for(unsigned int i=0; i< nos_cp; i++) {
		timeVector[i] = i * hold_time_dur;
		dataVector[i] = cps[i];
	}
	timeVector[(nos_cp - 1)] = th;	//to replace with the time-horizon value for the last CP since (i*hold_time_dur) may be less than 'th' due to numerical error
	// **** Code for ONE variable *********

	time_vector = timeVector;
	data_vector = dataVector;
}

//Function to generate spline signal, where the hold-time is fixed/uniform for each control-points
//  execute line_signal, then spline intepolate the result with period 0.5
void spline_signal(std::unique_ptr<MATLABEngine> &ep, double th, std::vector<double> cps, std::vector<double> &time_vector, std::vector<double> &data_vector) {
	// **** This code is only for a single variable *********
	unsigned int nos_cp= cps.size();

    if (nos_cp <= 1) {
		std::cout << "\nTerminating BBC4CPS, caused due to error in command-line inputs.\n" ;
		std::cout << "Invalid number-of-control-points. Minimum number of control-points for a variable is 2 for spline signal type.\n";
		exit(1);
	}

	double hold_time_dur = hold_time_dur = th/(nos_cp-1);

	//data [cp1 cp2  cp3]
	//timeVector[0 hold_time_dur*1   hold_time_dur*2]
	std::vector<double> timeVector(nos_cp);
	std::vector<double> dataVector(nos_cp);

	for(unsigned int i=0; i< nos_cp; i++) {
		timeVector[i] = i * hold_time_dur;
		dataVector[i] = cps[i];
	}
	timeVector[(nos_cp - 1)] = th;	//to replace with the time-horizon value for the last CP since (i*hold_time_dur) may be less than 'th' due to numerical error

    // Same as linear upto here

	//**** code above this is same as linear. Now for the above timeVector (=x) and dataVector(y) we compute sp_y = spline(x,y,query_x) *****
	/*
	 * Matlab code will be
	 * query_time = 0:time_step:time_horizon     or any value (eg 0.5) instead of time_step
	 * sp_y = spline(x,y, query_time)
	 * time_vector = query_time
	 * data_vector = sp_y
	 */

	std::string cmd1 = "thorizon = ";
	cmd1.append(to_string(th));
	cmd1.append(";");
	MATLAB_EVAL(ep, cmd1);

	std::vector<double> cppData = dataVector;
	size_t x=1, y=cppData.size();
	matlab::data::ArrayFactory factory;
	auto inputArray = factory.createArray({ x, y }, cppData.cbegin(), cppData.cend());
	MATLAB_SETVAR(ep, "myDataVector", inputArray);

	std::vector<double> cppTime = timeVector;
	assert(y == cppTime.size());
	matlab::data::ArrayFactory factory1;
	auto inputArray1 = factory1.createArray({ x, y }, cppTime.cbegin(), cppTime.cend());
	MATLAB_SETVAR(ep, "myTimeVector", inputArray1);

	std::string cmd2 = "query_time = 0:0.5:";
	cmd2.append(to_string(th));
	cmd2.append(";");
	MATLAB_EVAL(ep, cmd2);

	std::string cmd3 = "sp_y = spline(myTimeVector, myDataVector, query_time);";
	MATLAB_EVAL(ep, cmd3);

	matlab::data::TypedArray<double> query_time = ep->getVariable(u"query_time");
	std::vector<double> query_time_values(query_time.begin(), query_time.end());

	matlab::data::TypedArray<double> sp_y = ep->getVariable(u"sp_y");
	std::vector<double> sp_values(sp_y.begin(), sp_y.end());


	/*for(int i=0; i< query_time_values.size(); i++) {
		cout << query_time_values[i] << endl;
	}
	exit(1);*/


	time_vector = query_time_values;
	data_vector = sp_values;
}

// [ (t_i, p_i) ] for i in [0,10]
//   where
//     t_i = timeHorizon * i / 11
//     p_i = amplitude * sin( 2pi / 11 * i) + zero_offset
void sine_wave_signal(double timeHorizon, double amplitude, double zero_offset, std::vector<double> &time_vector, std::vector<double> &data_vector) {
    // **** This code is for ONE variable. It generate a full cycle sine wave for the given amplitude with starting from zero_offset *********

	unsigned int number_of_samples = 10; //a higher value gives better sine wave and more possibilities of covering full timeHorizon
								// Best value is number_of_samples = timeHorizon. so that per unit time a sampling is done.
	double value=0;

	float rads = M_PI/180;  //angle in radian, where M_PI is the pi value
	double step_size = 360 / timeHorizon; //for one full cycle

	std::vector<double> timeVector(number_of_samples + 1);
	std::vector<double> dataVector(number_of_samples + 1);

	unsigned int iteration_size = timeHorizon / (number_of_samples - 1); //to obtain less number of iterations i.e., higher iteration_size

    // rather than more iterations which will have issue on index out of bound while storing values in variables timeVector and dataVector
	unsigned int index=0;
	for(int i=0; i<=timeHorizon; i+=iteration_size)
	{
		value = (float)(amplitude * sin(step_size * i * rads) + zero_offset);
		dataVector[index] = value;
		timeVector[index] = i;
		index++;
	}

	//last value replace with i==timehorizon
	value = (float)(amplitude * sin(step_size * timeHorizon * rads) + zero_offset);

	dataVector[number_of_samples] = value;	//last index as per zero-based indexing
	timeVector[number_of_samples] = timeHorizon;

    // **** Code for ONE variable *********

	time_vector = timeVector;
	data_vector = dataVector;
}


